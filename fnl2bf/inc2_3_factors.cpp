/*
This is a Lua module that loads the file inc2-3.csv, generated by
../constants/inc2-3.jl, and provides a Lua function to access the data.

No validation of the input data is performed and the parsing is not safely implemented to improve performance.
*/

#define INC2_3_CSV_PATH "../constants/inc2-3.csv"

#include <array>
#include <cstdint>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>

// converts str to an int
int unsafe_stoi(std::string str)
{
    int i = (str[0] == '-') ? 1 : 0, result = 0;
    
    while (str[i] != '\0') {
        result = (result * 10) + (str[i] - '0');
        i++;
    }

    return (str[0] == '-') ? -result : result;
}

// return the substring from in that starts at i and ends at the first occurence of delimiter after i
// i is incremented by the length of the returned string + 1
inline std::string unsafe_getline(int& i, const std::string& in, const char delimiter)
{
    std::string out = "";
    while (in[i] != delimiter) {
        out += in[i];
        i++;
    }
    i++;
    return out;
}

extern "C" {
#include <lauxlib.h>
#include <lua.h>

bool is_loaded = false;
std::array<std::array<std::array<std::array<int8_t, 8>, 256>, 256>, 256> inc2_3_factors;

// load inc2-3.csv into inc2_3_factors
int load(lua_State* L)
{
    if(is_loaded){
        return 0;
    }

    std::ifstream csv_file(INC2_3_CSV_PATH);
    std::string line;

    if (csv_file.fail()) {
        return luaL_error(L, "failed to open " INC2_3_CSV_PATH);
    }

    while (std::getline(csv_file, line)) {
        int i = 0;
        line += ',';

        int r1 = unsafe_stoi(unsafe_getline(i, line, ','));
        int r2 = unsafe_stoi(unsafe_getline(i, line, ','));
        int r3 = unsafe_stoi(unsafe_getline(i, line, ','));

        inc2_3_factors[r1][r2][r3][0] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
        inc2_3_factors[r1][r2][r3][1] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
        inc2_3_factors[r1][r2][r3][2] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
        inc2_3_factors[r1][r2][r3][3] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
        inc2_3_factors[r1][r2][r3][4] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
        inc2_3_factors[r1][r2][r3][5] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
        inc2_3_factors[r1][r2][r3][6] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
        inc2_3_factors[r1][r2][r3][7] = (int8_t)unsafe_stoi(unsafe_getline(i, line, ','));
    }

    csv_file.close();
    is_loaded = true;
    return 0;
}

// get values from inc2_3_factors
int get(lua_State* L)
{
    uint8_t r1 = lua_tointeger(L, 1);
    uint8_t r2 = lua_tointeger(L, 2);
    uint8_t r3 = lua_tointeger(L, 3);

    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][0]);
    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][1]);
    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][2]);
    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][3]);
    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][4]);
    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][5]);
    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][6]);
    lua_pushinteger(L, inc2_3_factors[r1][r2][r3][7]);

    return 8;
}

// make the functions available to Lua
int luaopen_inc2_3_factors(lua_State* L)
{
    luaL_Reg fns[] = { { "load", load }, { "get", get }, { NULL, NULL } };
    luaL_newlib(L, fns);
    // luaL_register(L, "inc2_3_factors", fns);
    return 1;
}
}