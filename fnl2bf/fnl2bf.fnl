(local bf {})

"This is a Fennel library for working with Brainfuck code at a higher level.

**Note:** using the `inc2-3` function (and functions that depend on it) requires the following:
1. compile the `inc2_3_factors` module: `make` (or build it manually)
2. place the file `inc2-3.csv` (generated by `../constants/inc2-3.jl` or available from https://github.com/dokutan/bf-codegen/releases/tag/v0.1) in the same directory as the `inc2_3_factors` module

**Note:** the `inc2-n` function can use a C++ implementation (the `inc2_n` module) to improve performance, if this module is not available, a slower fennel implementation is used:
1. compile the `inc2_n` module: `make` (or build it manually)
2. place the file `inc2-n.csv` (generated by `../constants/inc2-n.jl`) in the same directory as the `inc2_n` module

**Note:** the `optimize` function can use a C++ implementation (the `optimize` module) to improve performance, if this module is not available, a slower fennel implementation is used:
1. compile the `optimize` module: `make` (or build it manually)

## Naming conventions:
symbol | meaning
---|---
`!` | modifies the current cell
`\\` | requires manual initialization of cells that are not specified as a parameter

Parameters beginning with `temp` are always pointers to cells."

(set bf.factors [
  [0 0 1]
  [0 0 2]
  [0 0 3]
  [0 0 4]
  [0 0 5]
  [3 2 0]
  [3 2 1]
  [4 2 0]
  [3 3 0]
  [5 2 0]
  [5 2 1]
  [4 3 0]
  [4 3 1]
  [7 2 0]
  [5 3 0]
  [4 4 0]
  [4 4 1]
  [6 3 0]
  [6 3 1]
  [5 4 0]
  [7 3 0]
  [7 3 1]
  [6 4 -1]
  [6 4 0]
  [5 5 0]
  [5 5 1]
  [9 3 0]
  [7 4 0]
  [7 4 1]
  [6 5 0]
  [6 5 1]
  [8 4 0]
  [8 4 1]
  [7 5 -1]
  [7 5 0]
  [6 6 0]
  [6 6 1]
  [6 6 2]
  [8 5 -1]
  [8 5 0]
  [8 5 1]
  [7 6 0]
  [7 6 1]
  [11 4 0]
  [9 5 0]
  [9 5 1]
  [8 6 -1]
  [8 6 0]
  [7 7 0]
  [10 5 0]
  [10 5 1]
  [13 4 0]
  [9 6 -1]
  [9 6 0]
  [11 5 0]
  [8 7 0]
  [8 7 1]
  [8 7 2]
  [10 6 -1]
  [10 6 0]
  [10 6 1]
  [9 7 -1]
  [9 7 0]
  [8 8 0]
  [8 8 1]
  [11 6 0]
  [11 6 1]
  [11 6 2]
  [10 7 -1]
  [10 7 0]
  [10 7 1]
  [9 8 0]
  [9 8 1]
  [9 8 2]
  [15 5 0]
  [11 7 -1]
  [11 7 0]
  [13 6 0]
  [10 8 -1]
  [10 8 0]
  [9 9 0]
  [9 9 1]
  [12 7 -1]
  [12 7 0]
  [12 7 1]
  [12 7 2]
  [11 8 -1]
  [11 8 0]
  [11 8 1]
  [10 9 0]
  [13 7 0]
  [13 7 1]
  [13 7 2]
  [12 8 -2]
  [12 8 -1]
  [12 8 0]
  [12 8 1]
  [14 7 0]
  [11 9 0]
  [10 10 0]
  [10 10 1]
  [10 10 2]
  [13 8 -1]
  [13 8 0]
  [15 7 0]
  [15 7 1]
  [12 9 -1]
  [12 9 0]
  [12 9 1]
  [11 10 0]
  [11 10 1]
  [14 8 0]
  [14 8 1]
  [14 8 2]
  [13 9 -2]
  [13 9 -1]
  [13 9 0]
  [13 9 1]
  [12 10 -1]
  [12 10 0]
  [11 11 0]
  [11 11 1]
  [11 11 2]
  [14 9 -2]
  [14 9 -1]
  [14 9 0]
  [14 9 1]
  [16 8 0]
  [13 10 -1]
  [13 10 0]
  [13 10 1]
  [12 11 0]
  [12 11 1]
  [15 9 -1]
  [15 9 0]
  [17 8 0]
  [17 8 1]
  [14 10 -2]
  [14 10 -1]
  [14 10 0]
  [14 10 1]
  [13 11 -1]
  [13 11 0]
  [12 12 0]
  [12 12 1]
  [12 12 2]
  [12 12 3]
  [15 10 -2]
  [15 10 -1]
  [15 10 0]
  [15 10 1]
  [19 8 0]
  [17 9 0]
  [14 11 0]
  [14 11 1]
  [13 12 0]
  [13 12 1]
  [13 12 2]
  [16 10 -1]
  [16 10 0]
  [16 10 1]
  [18 9 0]
  [18 9 1]
  [15 11 -1]
  [15 11 0]
  [15 11 1]
  [14 12 -1]
  [14 12 0]
  [13 13 0]
  [17 10 0]
  [19 9 0]
  [19 9 1]
  [19 9 2]
  [16 11 -2]
  [16 11 -1]
  [16 11 0]
  [16 11 1]
  [16 11 2]
  [15 12 -1]
  [15 12 0]
  [15 12 1]
  [14 13 0]
  [14 13 1]
  [14 13 2]
  [17 11 -2]
  [17 11 -1]
  [17 11 0]
  [17 11 1]
  [21 9 0]
  [19 10 0]
  [16 12 -1]
  [16 12 0]
  [16 12 1]
  [15 13 -1]
  [15 13 0]
  [14 14 0]
  [14 14 1]
  [18 11 0]
  [18 11 1]
  [20 10 0]
  [20 10 1]
  [17 12 -2]
  [17 12 -1]
  [17 12 0]
  [17 12 1]
  [17 12 2]
  [16 13 -1]
  [16 13 0]
  [19 11 0]
  [15 14 0]
  [15 14 1]
  [15 14 2]
  [15 14 3]
  [18 12 -2]
  [18 12 -1]
  [18 12 0]
  [18 12 1]
  [18 12 2]
  [20 11 -1]
  [20 11 0]
  [17 13 0]
  [17 13 1]
  [16 14 -1]
  [16 14 0]
  [15 15 0]
  [15 15 1]
  [19 12 -1]
  [19 12 0]
  [19 12 1]
  [23 10 0]
  [21 11 0]
  [21 11 1]
  [18 13 -1]
  [18 13 0]
  [18 13 1]
  [18 13 2]
  [17 14 -1]
  [17 14 0]
  [17 14 1]
  [16 15 0]
  [16 15 1]
  [22 11 0]
  [22 11 1]
  [22 11 2]
  [19 13 -2]
  [19 13 -1]
  [19 13 0]
  [19 13 1]
  [19 13 2]
  [18 14 -2]
  [18 14 -1]
  [18 14 0]
  [18 14 1]
  [17 15 -1]
  [17 15 0]
])

(λ bf.shortest [...]
  "Returns the shortest argument"
  (let [t [...]]
    (table.sort t (λ [a b] (< (length a) (length b))))
    (. t 1)))

(λ bf.shortest-in [tbl ?randomize]
  "Returns the shortest element from `tbl`
   If `?randomize` is true and there are multiple shortest elements, choose one randomly."
  (let [t tbl]
    (table.sort t (λ [a b] (< (length a) (length b))))
    (if (not ?randomize)
      (. t 1)
      (do
        (var shortest [])
        (each [_ v (ipairs t)]
          (when (<= (length v) (length (. t 1)))
            (table.insert shortest v)))
        (. shortest (math.random 1 (length shortest)))))))

(λ bf.loop [...]
  "A loop: [...]"
  (.. "[" (table.concat [...] "") "]"))

(λ bf.at [distance ...]
  "If `distance` is a number: Move pointer by `distance`, insert body, move back.
   `distance` can also be a table: `(bf.at [1 … 2 … 3 …])`"
  (case (type distance)
    :number
    (..
      (bf.ptr distance)
      (table.concat [...] "")
      (bf.ptr (- distance)))

    :table
    (faccumulate [result ""
                  i 1 (length distance) 2]
      (..
        result
        (bf.at (. distance i) (. distance (+ 1 i)))))))

(λ bf.ptr [distance ?from]
  "Move pointer by `distance`. If `?from` is not nil, assume the ptr starts at `?from`"
  (if
    (not= ?from nil) (bf.ptr (- distance ?from))
    (> distance 0)   (string.rep ">" distance)
    (< distance 0)   (string.rep "<" (- distance))
    ""))

(λ bf.inc [value]
  "Add `value` to current cell"
  (if
    (> value 255)
    (bf.inc (% value 256))

    (< value -255)
    (bf.inc (- (% (- value) 256)))

    (> (math.abs value) 127)
    (if
      (> value 0) (string.rep "-" (- 256 value))
      (< value 0) (string.rep "+" (- 256 (- value)))
      "")

    (if
      (> value 0) (string.rep "+" value)
      (< value 0) (string.rep "-" (- value))
      "")))

(λ bf.inc2 [value temp ?temp-initial]
  "Add `value` to the current cell, using `temp0`.
   `temp0` must be 0 or have the value `?temp-initial`."

  ;; load inc2-factors lazily to improve performance when it is not needed
  (when (not bf.inc2-factors)
    (tset bf :inc2-factors (require "inc2-factors")))

  (let [value (% value 256)
        ?temp-initial (or ?temp-initial 0)
        ?temp-initial (% ?temp-initial 256)
        [i1 il a1 al]
        (. bf.inc2-factors (.. value "," ?temp-initial))]
    (bf.shortest
      (bf.inc value)
      (..
        (if (and (= 0 ?temp-initial) (= 0 il))
          ""
          (..
            (bf.ptr temp)
            (bf.inc il)
            (bf.loop
              (bf.at (- temp)
                (bf.inc a1))
              (bf.inc al))
            (bf.ptr (- temp))))
        (bf.inc i1)))))

(λ bf.inc2-2 [value1 value2 at2 temp ?inc-after-loop]
  "Increment the current cell by `value1` and the cell at `at2` by `value2`.
   `temp` must be zero.
   If ?inc-after-loop is `true`, add i1, i2 after the loop."

  ;; load inc2-2-factors lazily to improve performance when it is not needed
  (when (not bf.inc2-2-factors)
    (tset bf :inc2-2-factors (require "inc2-2-factors")))

  (let [value1 (if (< value1 0) (+ 256 value1) value1)
        value2 (if (< value2 0) (+ 256 value2) value2)
        value1 (% value1 256)
        value2 (% value2 256)
        [i1 i2 il a1 a2 al]
        (. bf.inc2-2-factors (.. value1 "," value2))]
    (bf.shortest
      (if ?inc-after-loop
        (..
          (bf.ptr temp)
          (bf.inc il)
          (bf.loop
            (bf.ptr (- temp))
            (bf.inc a1)
            (bf.ptr at2)
            (bf.inc a2)
            (bf.ptr temp at2)
            (bf.inc al))
          (bf.ptr at2 temp)
          (bf.inc i2)
          (bf.ptr 0 at2)
          (bf.inc i1))

        (..
          (bf.inc i1)
          (bf.ptr at2)
          (bf.inc i2)
          (bf.ptr temp at2)
          (bf.inc il)
          (bf.loop
            (bf.ptr (- temp))
            (bf.inc a1)
            (bf.ptr at2)
            (bf.inc a2)
            (bf.ptr temp at2)
            (bf.inc al))
          (bf.ptr (- temp))))

      (..
        (bf.inc2 value1 temp)
        (bf.at at2
          (bf.inc2 value2 (- temp at2)))))))

(λ bf.inc2-3 [value1 value2 value3 at2 at3 temp]

  ;; load inc2_3_factors lazily to improve performance when it is not needed
  (when (not bf.inc2_3_factors)
    (tset bf :inc2_3_factors (require "inc2_3_factors"))
    (bf.inc2_3_factors.load))

  (let [(i1 i2 i3 il a1 a2 a3 al) (bf.inc2_3_factors.get value1 value2 value3)]
    (bf.shortest
      (..
                          (bf.inc i1)
        (bf.ptr at2)      (bf.inc i2)
        (bf.ptr at3 at2)  (bf.inc i3)
        (bf.ptr temp at3) (bf.inc il)
        (bf.loop
          (bf.ptr 0 temp)   (bf.inc a1)
          (bf.ptr at2 0)    (bf.inc a2)
          (bf.ptr at3 at2)  (bf.inc a3)
          (bf.ptr temp at3) (bf.inc al))
        (bf.ptr 0 temp))

      (..
        (bf.inc2 value1 temp)
        (bf.ptr at2)
        (bf.inc2 value2 (- temp at2))
        (bf.ptr at3)
        (bf.inc2 value3 (- temp at3))
        (bf.ptr 0 at3))

      (..
        (bf.inc2 value1 temp)
        (bf.ptr at2)
        (bf.inc2-2 value2 value3 (- at3 at2) (- temp at2))
        (bf.ptr 0 at2))

      (..
        (bf.inc2-2 value1 value2 at2 temp)
        (bf.ptr at3)
        (bf.inc2 value3 temp)
        (bf.ptr 0 at3)))))

(λ _inc2-n-cpp [value at temp]
  "The C++ implementation of inc2-n."
  (local inc2-n (require :inc2_n))

  ;; build the equivalent code without a loop
  (local result-no-loop
    (bf.optimize
      (faccumulate [result "" i 1 (length at)]
        (..
          result
          (bf.at (. at i) (bf.inc (. value i)))))))

  (bf.shortest
    (bf.optimize (inc2-n.inc2_n value at temp))
    result-no-loop))

(λ _inc2-n-fennel [value at temp]
  "The fennel implementation of inc2-n."

  ;; load inc2-n-factors lazily to improve performance when it is not needed
  (when (not bf.inc2-n-factors)
    (tset bf :inc2-n-factors (require "inc2-n-factors")))

  (fn cost [option]
    (+
      (math.abs (. option 1)) ; il
      (math.abs (. option 2)) ; al
      (accumulate [sum 0 _ i1-a1 (ipairs (. option 3))]
        (+
          sum
          (math.abs (. i1-a1 1))
          (math.abs (. i1-a1 2))))))

  ;; search for all il,al and i1,a1 that can generate all values
  (var options {})

  ;; TODO il and al should start at -20, this decreases the length in some cases but increases it in others. why?
  (for [il 0 20]
    (for [al 0 20]
      (var possible true)
      (let [i1-a1
            (icollect [_ r (ipairs value)]
              (do
                (when (not (. bf.inc2-n-factors (.. (% r 256) "," il "," al)))
                  (set possible false))
                (. bf.inc2-n-factors (.. (% r 256) "," il "," al))))]
        (when possible
          (table.insert options [il al i1-a1])))))

  ;; find the shortest option
  (var shortest-option (. options 1))
  (each [_ option (ipairs options)]
    (when (< (cost option) (cost shortest-option))
      (set shortest-option option)))

  ;; build brainfuck code
  (local result-loop
    (bf.optimize
      (..
        (accumulate [result "" i i1-a1 (ipairs (. shortest-option 3))] ; i1
          (..
            result
            (bf.at (. at i)
              (bf.inc2 (. i1-a1 1) 1))))
        (bf.at temp (bf.inc (. shortest-option 1))) ; il

        (bf.at temp
          (bf.loop
            (accumulate [result "" i i1-a1 (ipairs (. shortest-option 3))] ; a1
            (..
              result
              (bf.at (- (. at i) temp)
                (bf.inc (. i1-a1 2)))))
            (bf.inc (. shortest-option 2))))))) ; al

  ;; build the equivalent code without a loop
  (local result-no-loop
    (bf.optimize
      (faccumulate [result "" i 1 (length at)]
        (..
          result
          (bf.at (. at i) (bf.inc (. value i)))))))

  (bf.shortest
    result-loop
    result-no-loop))

(λ bf.inc2-n [value at temp]
  "Increment multiple cells using a single loop.
   `value` is a list containing the values that should be added.
   `at` is a list containing the positions of the modified cells.
   `temp` is the position of a cell containing 0, used as a loop counter.

   Example: `(bf.inc2-n [123 30 20 10] [0 1 2 3] 4)`

   This function replaces itself with _inc2-n-cpp or _inc2-n-fennel."

  (if (pcall #(require :inc2_n)) ; is the inc2_n c++ module available ?
    (tset bf :inc2-n _inc2-n-cpp)
    (tset bf :inc2-n _inc2-n-fennel))

  (bf.inc2-n value at temp))

(λ bf.zero []
  "Set current cell to 0"
  (bf.loop "-"))

(λ bf.set [value ?initial]
  "Set current cell to value"
  (if ?initial
    (bf.shortest
      (bf.inc (- value ?initial))
      (bf.set value))
    (..
      (bf.zero)
      (bf.inc value))))

(λ bf.set2 [value temp0 ?initial]
  "Set current cell to value, using `temp0`. `temp0` must be 0."
  (if ?initial
    (bf.shortest
      (bf.inc2 (- value ?initial) temp0)
      (bf.set2 value temp0))
    (..
      (bf.zero)
      (bf.inc2 value temp0))))

(λ bf.add! [to]
  "Add current cell to `to`.
   Sets the current cell to zero."
  (bf.loop
    (bf.at to
      "+")
    "-"))

(λ bf.multiply-add! [times to]
  "Add the value of the current cell times `times` to `to`.
   Sets the current cell to zero."
  (bf.loop
    (bf.at to
      (bf.inc times))
    "-"))

(λ bf.sub! [to]
  "Destructively subtract current cell from `to`"
  (bf.loop
    (bf.at to
      "-")
    "-"))

(λ bf.mul! [y temp0 temp1]
  "current cell <- current cell * cell at `y`.
   `temp0` and `temp1` must to be 0.
   `y` is not modified."
  (..
    (bf.add! temp1)

    (bf.ptr temp1)
    (bf.loop
      (bf.ptr y temp1)
      (bf.loop
        (bf.ptr 0 y) "+"
        (bf.ptr temp0) "+"
        (bf.ptr y temp0) "-")

      (bf.ptr temp0 y)
      (bf.loop
        (bf.ptr y temp0) "+"
        (bf.ptr temp0 y) "-")

      (bf.ptr temp1 temp0) "-")

    (bf.ptr 0 temp1)))

(λ bf.square [temp0 temp1]
  "current cell < current cell ^ 2"
  (..
    (bf.add! temp0)
    (bf.at temp0
      (bf.loop
        "-"
        (bf.loop
          (bf.at (- temp1 temp0) "+")
          (bf.at (- 0 temp0) "++")
          "-")
        (bf.at (- 0 temp0) "+")
        (bf.at (- temp1 temp0)
          (bf.add! (- temp0 temp1)))))))

(λ bf.divmod\! []
  "Current cell divided/modulo by the next cell to the right.
   Uses 5 cells to the right of the current cell, cells must be initialized as shown:
   - Before: `>n d 1 0 0 0`
   - After:  `>0 d-n%d n%d n/d 0 0`"
  (..
    "[->-[>+>>]>[[-<+>]+>+>>]<<<<<]"
    (bf.at 2 "-")))

(λ bf.divmod-by! [value]
  "Current cell divided/modulo by value. Uses 5 cells to the right of the current cell."
  (..
    ;; prepare temp cells
    (bf.at 5 (bf.zero))
    (bf.at 4 (bf.zero))
    (bf.at 3 (bf.zero))
    (bf.shortest
      (..
        (bf.at 2 (bf.zero))
        (bf.at 1 (bf.set2 value 1))
        (bf.at 2 "+"))
      (..
        (bf.at 2 (bf.set 1))
        (bf.at 1 (bf.set value))))

    (bf.divmod\!)))

(λ bf.mod\! []
  "- before: `0 >n d 0 0 0`
   - after: `0 >0 d-n%d n%d 0 0`"
  "[>->+<[>]>[<+>-]<<[<]>-]")

(λ bf.invert [temp ?init]
  "Equivalent to current cell <- (256 - current cell)."
  (..
    (if ?init (bf.at temp (bf.zero)) "")
    (bf.loop
      (bf.at temp "-")
      "-")
    (bf.at temp
      (bf.loop
        (bf.at (- temp) "-")
        "+"))
    ))

(λ bf.mov! [to]
  "Destructively move current cell to `to`"
  (..
    (bf.at to
      (bf.zero))
    (bf.add! to)))

(λ bf.mov [to temp ?init]
  "Copy value of the current cell to `to`, using `temp`.
   `temp` and `to` must be manually set to 0, unless `?init` is true."
  (..
    (if ?init
      (..
        (bf.at to   (bf.zero))
        (bf.at temp (bf.zero)))
      "")

    (bf.loop
      (bf.ptr to)
      "+"
      (bf.ptr (- temp to))
      "+"
      (bf.ptr (- temp))
      "-")

    ;; restore original value
    (bf.ptr temp)
    (bf.add! (- temp))
    (bf.ptr (- temp))))

(λ bf.add [to temp]
  "Add the value of the current cell to `to`, using `temp`.
   `temp` must be zero."
  (bf.mov to temp false))

(λ bf.swap [y temp0]
  "Swap the current cell with `y`, using `temp0`. `temp0` must be 0."
  (..
    (bf.loop
      "-"
      (bf.ptr temp0) "+"
      (bf.ptr y temp0) "-"
      (bf.ptr 0 y))

    (bf.at y
      (bf.loop
        "-"
        (bf.at (- y) "+")))

    (bf.at temp0
      (bf.loop
        "-"
        (bf.ptr y temp0) "+"
        (bf.ptr 0 y) "+"
        (bf.ptr temp0)))))

(λ bf.not=! [y]
 "current cell <- current cell != cell at `y`. Sets `y` to 0."
 (..
  (bf.loop
    (bf.at y
      "-")
    "-")
  (bf.at y
    (bf.loop
      (bf.zero)
      (bf.at (- y)
        "+")))))

(λ bf.=! [y]
 "current cell <- current cell == cell at `y`. Sets `y` to 0."
 (..
  (bf.loop
    (bf.at y
      "-")
    "-")
  "+"
  (bf.at y
    (bf.loop
      (bf.zero)
      (bf.at (- y)
        "-")))))

(λ bf.<\! [?init]
  "current cell <- current cell < next cell.
  - before: >x y 0 0
  - after: >(x<y) 0 0 0"
  (..
    (if ?init
      (..
        (bf.at 2 (bf.zero))
        (bf.at 3 (bf.zero)))
      "")
    "[->>+<[->-]>[<<[-]>>->]<<<]>[[-]<+>]<"))

(λ bf.>! [x y z temp0 temp1 ?init]
  "z = x>y
   Modifies x and y. z, temp0 and temp1 must be zero, unless ?init is true."
  (..
    (if ?init
      (..
        (bf.at temp0 (bf.zero))
        (bf.at temp1 (bf.zero))
        (bf.at z (bf.zero)))
      "")
    (bf.at x
      (bf.loop
        (bf.at (- temp0 x) "+")
        (bf.at (- y x)
          (bf.loop
            "-"
            (bf.at (- temp0 y) (bf.zero))
            (bf.at (- temp1 y) "+")))
        (bf.at (- temp0 x)
          (bf.loop
            "-"
            (bf.at (- z temp0) "+")))
        (bf.at (- temp1 x)
          (bf.loop
            "-"
            (bf.at (- y temp1) "+")))
        (bf.at (- y x) "-")
        "-"))))

(λ bf.max [x y maximum temp0 temp1 temp2 temp3 temp4]
  ""
  (..
    (bf.at y (bf.mov (- maximum y) (- temp0 y)))
    (bf.at x (bf.mov (- temp0 x)   (- temp1 x)))
    (bf.at y (bf.mov (- temp1 y)   (- temp2 y)))
    (bf.>! temp0 temp1 temp2 temp3 temp4)
    (bf.at temp0 (bf.zero))
    (bf.at temp1 (bf.zero))
    (bf.at temp2
      (bf.if
        (bf.at (- maximum temp2)
          (bf.zero))
        (bf.at (- x temp2)
          (bf.mov (- maximum x) (- temp0 x)))))))

(λ bf.min [x y minimum temp0 temp1 temp2 temp3 temp4]
  ""
  (..
    (bf.at x (bf.mov (- minimum x) (- temp0 x)))
    (bf.at x (bf.mov (- temp0 x)   (- temp1 x)))
    (bf.at y (bf.mov (- temp1 y)   (- temp2 y)))
    (bf.>! temp0 temp1 temp2 temp3 temp4)
    (bf.at temp0 (bf.zero))
    (bf.at temp1 (bf.zero))
    (bf.at temp2
      (bf.if
        (bf.at (- minimum temp2)
          (bf.zero))
        (bf.at (- y temp2)
          (bf.mov (- minimum y) (- temp0 y)))))))

(λ bf.zero? [temp0 temp1]
  "Set temp1 to 1 if current cell == 0, else to 0.
   The current cell is not modified.
   `temp0` and `temp1` must be initialised with 0."
  (..
    (bf.mov temp0 temp1)
    (bf.at temp1 "+")
    (bf.at temp0
      (bf.if
        (bf.at (- temp1 temp0) "-")))))

(λ bf.if [...]
  "Equivalent to `[...[-]]`. Sets the current cell to 0."
  (bf.loop
    (table.concat [...] "")
    (bf.zero)))

(λ bf.if= [value temp0 temp1 ...]
  "If current cell == `value`, then ...
   The body is run at `temp0` and should not change the ptr.
   `temp0` and `temp1` must be 0."
  (..
    (bf.mov temp0 temp1)
    (bf.at temp1
      (bf.set value))
    (bf.at temp0
      (bf.not=! (- temp1 temp0))
      "-"
      (bf.loop
        (table.concat [...] "")
        (bf.zero)))))

(λ bf.if2= [value temp0 temp1 temp2 ...]
  "If current cell == `value`, then ...
   The body is run at `temp0` and should not change the ptr.
   `temp2`must be 0."
  (..
    (bf.mov temp0 temp1)
    (bf.at temp1
      (bf.set2 value temp2))
    (bf.at temp0
      (bf.not=! (- temp1 temp0))
      "-"
      (bf.loop
        (table.concat [...] "")
        (bf.zero)))))

(λ bf.if-not= [value temp0 ...]
  "If current cell ≠ `value`, then ...
   The body is run at the current cell.
   Sets the current cell to 0."
  (..
    (bf.inc2 (- value) temp0)
    (bf.loop
      (bf.inc2 value temp0)
      (table.concat [...] "")
      (bf.zero))))

(λ bf.do-times [n temp ...]
  "Run the body `n` times."
  (bf.at temp
    (bf.set n)
    (bf.loop
      (bf.at (- temp)
        (table.concat [...] ""))
      "-")))

(λ bf.do-times-at [temp ...]
  "Run the body n times, n = value of `temp`."
  (bf.at temp
    (bf.loop
      (bf.at (- temp)
        (table.concat [...] ""))
      "-")))

"# Print functions"

(λ bf.print-cell\ []
  "Print the value of the current cell as a decimal number.
   Requires 9 cells containing 0 to the right of the current cell."
  (..
    ">>++++++++++<<[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]>>[-]>>>++++++++++<[->-[>+"
    ">>]>[+[-<+>]>+>>]<<<<<]>[-]>>[>++++++[-<++++++++>]<.<<+>+>[-]]<[<[->-<]++"
    "++++[->++++++++<]>.[-]]<<++++++[-<++++++++>]<.[-]<<[-<+>]<"))

(λ bf.print-cell-tens\ []
  "Print the value of the current cell modulo 10 as a decimal number.
   Requires 9 cells containing 0 to the right of the current cell."
  (..
    ">>++++++++++<<[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]>>[-]>>>++++++++++<[->-[>+"
    ">>]>[+[-<+>]>+>>]<<<<<]>[-]>>[-]<[<[->-<]++++++[->++++++++<]>.[-]]<<+++++"
    "+[-<++++++++>]<.[-]<<[-<+>]<"))

(λ bf.print-cell-tens\! []
  "Print the value of the current cell.
   Requires 5 zeroed cells to the right and handles values >99 incorrectly.
   Sets the current cell to 0."
  (..
    (bf.at 1 (bf.inc 10))
    (bf.at 2 (bf.inc 1))
    (bf.divmod\!)
    ;; print tens
    (bf.at 3
      (bf.mov 1 2)
      (bf.if
        (bf.at 1
          (bf.inc2 48 1)
          "."
          (bf.zero))))
    ;; print ones
    (bf.at 2
      (bf.inc2 48 1)
      "."
      (bf.zero))
    (bf.at 1 (bf.zero))))

(λ bf.print-cell-tens-padded\! []
  "Print the value of the current cell padded with 0 to two digits.
   Requires 5 zeroed cells to the right and handles values >99 incorrectly.
   Sets the current cell to 0."
  (..
    (bf.at 1 (bf.inc 10))
    (bf.at 2 (bf.inc 1))
    (bf.divmod\!)
    (bf.at 2
      (bf.inc2-2 48 48 1 2))
    (bf.at 3 "." (bf.zero))
    (bf.at 2 "." (bf.zero))
    (bf.at 1 (bf.zero))))


(λ bf.print-cell-negative\ []
  "Print the value of the current cell in the range -128..127."
  (..
    (bf.mov 3 4 true) ; copy value
    (bf.at 1 "+") ; else flag

    ;; if number > 127: negative number
    (bf.at 2
      (bf.set2 127 2)
      (bf.<\! true)
      (bf.if
        (bf.print2! "-" 1)
        (bf.at -1 "-")
        (bf.at -2
          (bf.invert 1)
          (bf.at [1 (bf.zero) 2 (bf.zero)])
          (bf.print-cell\)
          (bf.invert 1))))

    ;; else: positive number
    (bf.at 1
      (bf.if
        (bf.at -1
        (bf.at [1 (bf.zero) 2 (bf.zero)])
        (bf.print-cell\))))))

(λ bf.print! [str ?initial]
  "Print `str` using the current cell.
   The value of the current cell is assumed to be `?initial`, if given."
  (if ?initial

    (faccumulate [result ""
                  i 1 (length str)]
      (.. result
          (bf.shortest
            (bf.inc (- (string.byte str i)
                       (or (string.byte str (- i 1)) ?initial)))
            (bf.set (string.byte str i)))
          "."))

    (..
      (bf.zero)
      (bf.print! str 0))))

(λ bf.print2! [str temp0 ?initial]
  "Print `str` using the current cell and `temp0`, `temp0` must be 0.
   The value of the current cell is assumed to be `?initial`, if given."
  (if ?initial

    (faccumulate [result ""
                  i 1 (length str)]
      (.. result
          (bf.shortest
            (bf.inc2 (- (string.byte str i)
                        (or (string.byte str (- i 1)) ?initial))
                     temp0)
            (bf.set2 (string.byte str i) temp0))
          "."))

    (..
      (bf.zero)
      (bf.print2! str temp0 0))))

(λ bf.print2+! [str temp0 ?initial]
  "Print `str` using the current cell and `temp0`, `temp0` must be 0.
   The value of the current cell is assumed to be `?initial`, if given."
  (fn print2+! [swapfn str temp0 ?initial]
    (var last-current ?initial)
    (var last-temp 0) ; TODO add as parameter

    (if ?initial
      (faccumulate [result ""
                    i 1 (length str)]
        (let [swapped? (swapfn 0 (% i 2)) ; TODO try both this and: (not= 0 (% i 2))

              print-char
              (..
                ;; TODO: explore alternatives, e.g. zero+inc, no swapping, ...
                ; (bf.inc2 (- (string.byte str i)
                ;             (or (string.byte str (- i 1)) ?initial))
                ;          temp0)
                ; (bf.set2 (string.byte str i) temp0)

                (if swapped? ; current cell is temp0, temp cell is -temp0
                  (bf.at temp0
                    (bf.inc2
                      (- (string.byte str i) last-temp)
                      (- temp0)
                      last-current)
                    ".")
                  (..
                    (bf.inc2
                      (- (string.byte str i) last-current)
                      temp0
                      last-temp)
                    ".")
                  ))

              last-temp-value ; value of the cell last used as temp
              (if
                (string.find print-char "%[") 0
                swapped? last-current
                last-temp)]

          ;; update last-current and last-temp
          (if swapped?
            (do
              (set last-current last-temp-value)
              (set last-temp (string.byte str i)))
            (do
              (set last-temp last-temp-value)
              (set last-current (string.byte str i))))

          (.. result print-char)))

      ;; else
      (..
        (bf.zero)
        (print2+! swapfn str temp0 0))))

    (bf.shortest
      (print2+! #(= $1 $2) str temp0 ?initial)
      (print2+! #(not= $1 $2) str temp0 ?initial)))

(λ bf.print2++! [str temp0 ?initial]
  "Print `str` using the current cell and `temp0`, `temp0` must be 0.
   The value of the current cell is assumed to be `?initial`, if given.
   TODO! Does not work reliably."
  (var last-current ?initial)
  (var last-temp 0) ; TODO add as parameter

  (if ?initial
    (faccumulate [result ""
                  i 1 (length str)]
      (let [a1
            (bf.at temp0
              (bf.inc2
                (- (string.byte str i) last-temp)
                (- temp0)
                last-current)
              ".")

            a2
            (..
              (bf.inc2
                (- (string.byte str i) last-current)
                temp0
                last-temp)
              ".")

            a3
            (bf.at temp0
              (bf.zero)
              (bf.inc2
                (string.byte str i)
                (- temp0)
                last-current)
              ".")

            a4
            (..
              (bf.zero)
              (bf.inc2
                (string.byte str i)
                temp0
                last-temp)
              ".")

            A1 (bf.optimize (.. result a1))
            A2 (bf.optimize (.. result a2))
            A3 (bf.optimize (.. result a3))
            A4 (bf.optimize (.. result a4))

            shortest-alternative
            (bf.shortest A1 A2 A3 A4)]

        ;; update last-current and last-temp
        (if
          ;; setting temp, zeroing current
          (and (= shortest-alternative A1) (string.find a1 ">"))
          (do
            (set last-current 0)
            (set last-temp (string.byte str i)))

          ;; setting current, zeroing temp
          (and (= shortest-alternative A2) (string.find a2 ">"))
          (do
            (set last-current (string.byte str i))
            (set last-temp 0))

          ;; setting temp, zeroing current
          (and (= shortest-alternative A3) (string.find a3 ">"))
          (do
            (set last-current 0)
            (set last-temp (string.byte str i)))

          ;; setting current, zeroing temp
          (and (= shortest-alternative A4) (string.find a4 ">"))
          (do
            (set last-current (string.byte str i))
            (set last-temp 0))

          ;; setting temp, not changing current
          (= shortest-alternative A1)
          (set last-temp (string.byte str i))

          ;; setting current, not changing temp
          (= shortest-alternative A2)
          (set last-current (string.byte str i))

          ;; setting temp, not changing current
          (= shortest-alternative A3)
          (set last-temp (string.byte str i))

          ;; setting current, not changing temp
          (= shortest-alternative A4)
          (set last-current (string.byte str i))

          )

        shortest-alternative))

    ;; else
    (..
      (bf.zero)
      (bf.print2++! str temp0 0))))

(fn bf.print3! [str temp0 temp1 ?initial]
  "Print `str` using the current cell, `temp0` and `temp1`, `temp0` and `temp1` must be 0.
   The value of the current cell is assumed to be `?initial`, if given.
   `temp0` can have a non-zero value afterwards."
  (fn print3 [str temp0 temp1 ?initial]
    (faccumulate [result ""
                  i 1 (length str) 2]
      (.. result
          (if (< i (length str)) ; current byte not the last byte
            (..
              (bf.inc2-2
                (if (> i 2)
                  (- (string.byte str i) (string.byte str (- i 2)))
                  (- (string.byte str i) (if ?initial ?initial 0)))
                (if (> i 2)
                  (- (string.byte str (+ 1 i)) (string.byte str (- i 1)))
                  (string.byte str (+ 1 i)))
                temp0
                temp1)
              "." (bf.at temp0 "."))
            ;; else
            (..
              (bf.set2
                (string.byte str i)
                temp1
                (if (> i 2)
                  (string.byte str (- i 2))
                  0))
              ".")))))
    (bf.shortest
      (bf.print2! str temp1 ?initial)
      (bf.print2! str temp0 ?initial)
      (print3 str temp0 temp1 ?initial)
      (print3 str temp1 temp0 ?initial)))

; (λ bf.print-from-memory [str memory ptr ?randomize ?zero-delimited]
;   "Print `str`, assumes the memory is initialized with the values from `memory`.
;    `memory` is modified in place.
;    `ptr` is the initial pointer position in `memory`.
;    `?randomize` is passed to `shortest-in`
;    Set `?zero-delimited` to true, if `memory` is delimited by 0 on both ends,
;    and doesn't contain 0. This makes pointer movement more efficient."
;   (fn move-ptr [from to]
;     (if ?zero-delimited
;       (bf.shortest
;         (bf.ptr (- to from))
;         (.. "[<]" (bf.ptr to))
;         (.. "[>]" (bf.ptr (- to (+ 1 (length memory))))))
;       (bf.ptr (- to from))))

;   (fn print-char [char memory ptr]
;     ;; for each cell in memory: try move + set + print
;     (var modified-index {})
;     (let [alternatives
;           (fcollect [i 1 (length memory)]
;             (let [p
;                   (..
;                     (move-ptr ptr i)
;                     (bf.set char (. memory i))
;                     ".")]
;               (tset modified-index p i)
;               p))

;           shortest-alternative
;           (bf.shortest-in alternatives ?randomize)]

;       (tset memory (. modified-index shortest-alternative) char)
;       (values
;         shortest-alternative
;         (. modified-index shortest-alternative))))

;   (table.unpack
;     (faccumulate [result ["" ptr]
;                   i 1 (length str)]
;       (let [(code new-ptr)
;             (print-char (string.byte str i i) memory (. result 2))]
;         [(.. (. result 1) code)
;          new-ptr]))))

(λ bf.print-from-memory [str memory ptr ?randomize ?zero-delimited]
  "Print `str`, assumes the memory is initialized with the values from `memory`.
   `memory` is modified in place.
   `ptr` is the initial pointer position in `memory`.
   `?randomize` is passed to `shortest-in`
   Set `?zero-delimited` to true, if `memory` is delimited by 0 on both ends,
   and doesn't contain 0. This makes pointer movement more efficient."
  (fn move-ptr [from to]
    (if ?zero-delimited
      (bf.shortest
        (bf.ptr (- to from))
        (.. "[<]" (bf.ptr to))
        (.. "[>]" (bf.ptr (- to (+ 1 (length memory))))))
      (bf.ptr (- to from))))

  (fn print-1-char [chars memory ptr]
    (var modified-index {}) ; alternative → new ptr == modified cell
    (let [char
          (. chars 1)

          alternatives []

          ;; try a few common alternatives to avoid a full search
          _
          (do
            (when (= (. memory ptr) char)
              (tset modified-index "." ptr)
              (table.insert alternatives "."))

            (when (= (. memory ptr) (- char 1))
              (tset modified-index "+." ptr)
              (table.insert alternatives "+."))

            (when (= (. memory ptr) (+ char 1))
              (tset modified-index "-." ptr)
              (table.insert alternatives "-."))

            (when (= (. memory (- ptr 1)) char)
              (tset modified-index "<." (- ptr 1))
              (table.insert alternatives "<."))

            (when (= (. memory (+ ptr 1)) char)
              (tset modified-index ">." (+ ptr 1))
              (table.insert alternatives ">.")))

          alternatives
          (if (not= 0 (length alternatives))
            alternatives
            (fcollect [i 1 (length memory)]
              (let [p
                    (..
                      (move-ptr ptr i)
                      (bf.set char (. memory i))
                      ".")]
                (tset modified-index p i)
                p)))

          shortest-alternative
          (bf.shortest-in alternatives ?randomize)]

      (tset memory (. modified-index shortest-alternative) char)
      (table.remove chars 1)

      (values
        shortest-alternative
        (. modified-index shortest-alternative))))

  (fn print-chars [chars memory ptr]
    (let [cost 3]
      (var start-l nil) ; initial index for ≶±[.>]
      (var start-r nil) ; initial index for ≶±[.<]

      ;; find start-l
      (for [i (- (length memory) cost) 2 -1]
        (when
          (faccumulate [r true
                        j i (length memory)]
            (and r (= (. memory j) (. chars (+ (- j i) 2)))))
          (set start-l (- i 1))))

      ;; find start-r
      (for [i cost (- (length memory) 1)]
        (when
          (faccumulate [r true
                        j i 1 -1]
            (and r (= (. memory j) (. chars (+ (- i j) 2)))))
          (set start-r (+ i 1))))

      (if
        start-r
        (let [code
              (..
                (move-ptr ptr start-r)
                (bf.set (. chars 1) (. memory start-r))
                "[.<]>")]
          ;(print start-r)
          (tset memory start-r (. chars 1))
          (for [i 1 start-r] (table.remove chars 1))
          (values code 1))

        start-l
        (let [code
              (..
                (move-ptr ptr start-l)
                (bf.set (. chars 1) (. memory start-l))
                "[.>]<")]
          ;(print start-l)
          (tset memory start-l (. chars 1))
          (for [i start-l (length memory)] (table.remove chars 1))
          (values code (length memory)))

        ;; else
        (print-1-char chars memory ptr))))

  (let [chars
        (fcollect [i 1 (length str)]
          (string.byte str i))]
    (var ptr ptr)
    (var result "")
    (while (> (length chars) 0)
      (let [(code new-ptr)
            (print-chars chars memory ptr)]
        (set ptr new-ptr)
        (set result (.. result code))))
    (values result ptr)))

"# String constructors"

(λ bf.string! [str move]
  "Store `str` in memory, starting at the current cell.
   All used cells must be initialized as 0. `move` should be ±1."
  (faccumulate [result ""
                i 1 (length str)]
    (.. result
        (bf.inc2 (string.byte str i) move)
        (bf.ptr move))))

(λ bf.string-opt1! [str move]
  "Slightly optimized version of `bf.string!`.
   Store `str` in memory, starting at the current cell.
   All used cells must be initialized as 0. `move` should be ±1."
  (faccumulate [result ""
                i 1 (length str)]
    (.. result
        ;; current byte = last byte ?
        (if (and (> i 1) (= (string.byte str i) (string.byte str (- i 1))))

          ;; try copying the last byte
          (bf.shortest
            (..
              (bf.at (- move)
                (bf.mov move (* 2 move)))
              (bf.set2 (string.byte str i) move (string.byte str (- i 1))))
            (bf.inc2 (string.byte str i) move))

          ;; else
          (bf.inc2 (string.byte str i) move))
        (bf.ptr move))))

(λ bf.string-opt2! [str move]
  "Better optimized version of `bf.string!`.
   Store `str` in memory, starting at the current cell.
   All used cells must be initialized as 0. `move` should be ±1."

  (fn count [str i]
    "Count how many initial bytes of `str` share the same `bf.factors.1`"
    (if
      (= nil i)
      (count str 2)

      (> i (length str))
      (- i 1)

      (=
        (. bf.factors (string.byte str 1 1) 1)
        (. bf.factors (string.byte str i i) 1))
      (count str (+ i 1))

      (- i 1)))

  (fn iterate [result str]
    (if (= "" str)
      result
      (let [this (string.byte str 1 1)]
        (iterate
          (..
            result

            ;; initialize all current cells with factors.3
            (bf.ptr (- move))
            (faccumulate [r "" i 1 (count str)]
              (..
                r
                (bf.ptr move)
                (bf.inc (. bf.factors (string.byte str i i) 3))))

            ;; add factors.2 × factors.1
            (bf.at move
              (bf.inc (. bf.factors this 1))
              (bf.loop
                (faccumulate [r "" i (count str) 1 -1]
                  (..
                    r
                    (bf.at (- (* (- (count str) i -1) move))
                      (bf.inc (. bf.factors (string.byte str i i) 2)))))
                "-"))

            ;; move to the next position
            (bf.ptr move))

          (string.sub str (+ 1 (count str)))))))

  (iterate "" str))

(λ bf.string-opt3! [str move]
  "Optimized version of `bf.string!`.
   Store `str` in memory, starting at the current cell.
   All used cells must be initialized as 0. `move` should be ±1."
  (fn string-opt3 [str move]
    (faccumulate [result ""
                  i 1 (length str) 2]
      (.. result
          (if (< i (length str)) ; current byte not the last byte
            (..
              (bf.inc2-2 (string.byte str i) (string.byte str (+ 1 i)) move (* 2 move))
              (bf.ptr move))

            ;; else
            (bf.inc2 (string.byte str i) move))
          (bf.ptr move))))

  (bf.shortest
    (string-opt3 str move)
    (..
      (bf.inc2 (string.byte str 1 1) move)
      (bf.ptr move)
      (string-opt3 (string.sub str 2) move))))

(λ bf.string-opt4! [str move]
  "Optimized version of `bf.string!`.
   Store `str` in memory, starting at the current cell.
   All used cells must be initialized as 0. `move` should be ±1."
  (fn string-opt4 [str move]
    (faccumulate [result ""
                  i 1 (length str) 3]
      (.. result
          (if
            (< (+ 1 i) (length str)) ; current byte not the second last byte
            (..
              (bf.inc2-3 (string.byte str i) (string.byte str (+ 1 i)) (string.byte str (+ 2 i)) move (* 2 move) (* 3 move))
              (bf.ptr (* 3 move)))

            (< i (length str)) ; current byte not the last byte
            (..
              (bf.inc2-2 (string.byte str i) (string.byte str (+ 1 i)) move (* 2 move))
              (bf.ptr (* 2 move)))

            ;; else
            (..
              (bf.inc2 (string.byte str i) move)
              (bf.ptr move))))))

  (bf.shortest
    (string-opt4 str move)
    (..
     (bf.inc2 (string.byte str 1 1) move)
     (bf.ptr move)
     (string-opt4 (string.sub str 2) move))))

(λ bf.string-opt5! [str move ?loop-size]
  "Optimized version of `bf.string!`.
   Store `str` in memory, starting at the current cell.
   All used cells (length of str + 1) must be initialized as 0. `move` should be ±1.
   ?loop-size is the number cells changed with one loop, the default is 10."

  (let [loop-size (if ?loop-size ?loop-size 10)]
      (fn inc-n [n i]
      "`n`: number of bytes to be processed, `i` current string index"
      (..
        (bf.inc2-n
          (fcollect [j 0 (- n 1)]
            (string.byte str (+ i j)))
          (fcollect [j 0 (- n 1)]
            (* j move))
          (* n move))
        (bf.ptr (* n move))))

    (fn string-opt5 [str]
      (faccumulate [result ""
                    i 1 (length str) loop-size]


        (.. result
            (if (<= (+ (- (length str) i) 1) loop-size)
              (inc-n (+ (- (length str) i) 1) i)
              (inc-n loop-size i)))))

    (string-opt5 str)))

(λ bf.string-opt6! [str move ?loop-size ?initial-value]
  "Optimized version of `bf.string!`.
   Store `str` in memory, starting at the current cell.
   All used cells (length of str + 1) must be initialized as `?initial-value` (default 0).
   `move` should be ±1.
   ?loop-size is the number cells changed with one loop, the default is 10."

  (local initial-value (or ?initial-value 0))

  ;; TODO using multiple loop sizes in a single string can reduce the code size:
  ;; (let [loop-size (if ?loop-size (+ ?loop-size (math.random -5 5)) 10)]
  (let [loop-size (if ?loop-size ?loop-size 10)]

    (fn inc-n [n i]
      "`n`: number of bytes to be processed, `i` current string index"
      (bf.shortest
        ;; try set each cell individually
        ;; TODO move this to a set-n function
        (faccumulate [r "" j 0 (- n 1)]
          (.. r
              (bf.set (string.byte str (+ i j)) ?initial-value)
              (bf.ptr move)))

        ;; try to use inc2-n
        (bf.optimize
          (..
            (->
              (bf.inc2-n
                (fcollect [j 0 (- n 1)]
                  (% (- (string.byte str (+ i j))
                        initial-value)
                    256))
                (fcollect [j 0 (- n 1)]
                  (* j move))
                (* n move))
              (string.gsub "%[" (.. (bf.inc (- initial-value)) "["))
              (string.gsub "%]" (.. "]" (bf.inc initial-value))))
            (bf.ptr (* n move))))))

    (fn string-opt6 [str]
      (faccumulate [result ""
                    i 1 (length str) loop-size]
        (.. result
            (if (<= (+ (- (length str) i) 1) loop-size)
              (inc-n (+ (- (length str) i) 1) i)
              (inc-n loop-size i)))))

    (..
      (string-opt6 str)
      (bf.zero))))

(λ bf.string2! [str move temp0 initial]
  "TODO! remove when bf.string2-opt! works
  Store `str` in memory, starting at the current cell.
  All used cells must be initialized as 0. `move` should be ±1.
  `initial` can be any number between 1 and 255."
  (let [result
        (..
          (bf.ptr temp0)
          (bf.set (. bf.factors initial 1)) ; set temp0 to factor.1

          (bf.loop ; while temp0 > 0
            (bf.ptr (- temp0))

            ;; add factor.2 to each string cell
            (string.rep
              (..
                (bf.inc (. bf.factors initial 2))
                (bf.ptr move))
              (length str))
            (bf.ptr (* (length str) (- move)))

            (bf.ptr temp0) ; decrement temp0
            "-")

          (bf.ptr (- temp0)))]

    (..
      ;; change each string cell from the initial value
      (faccumulate [result result
                    i 1 (length str)]
        (.. result
            (bf.inc (% (- (string.byte str i)
                         (* (. bf.factors initial 1)
                            (. bf.factors initial 2)))
                      256))
            (bf.ptr move)))

      ;; move back to the initial cell, TODO: replace with loop if possible
      (bf.ptr (* (length str) (- move))))))

(λ bf.string2-opt! [str move initial]
  "TODO! fails for some `initial` values
   Store `str` in memory, starting at the current cell.
   All used cells must be initialized as 0. `move` should be ±1.
   `initial` can be any number between 1 and 255."
  (let [initial (if (= initial (string.byte str 1 1)) 0 initial)
        str-
        (faccumulate [r "" i 1 (length str)]
          (..
            r
            (string.char
              (if (< (string.byte str i i) initial)
                (+ 256 (- (string.byte str i i) initial))
                (- (string.byte str i i) initial)))))]

    (..
      (bf.string! str- move)

      (if (= 0 initial)
        ""
        (..
          (bf.ptr (* -1 (length str) move))
          (bf.loop
            (bf.inc initial)
            (bf.ptr move)))))))

(λ _optimize-cpp [code ?_]
  "Remove useless combinations of brainfuck commands from `code`"
  (local optimize (. (require :optimize) :optimize))

  (-> code ; TODO improve this
    (optimize)
    (string.gsub "(>>[%+%-]+%[<<[%+%-]+>>[%+%-]+%]<<)([%+%-]+)" "%2%1")
    (string.gsub "(>[%+%-]+%[<[%+%-]+>[%+%-]+%]<)([%+%-]+)" "%2%1")
    (string.gsub "(<[%+%-]+%[>[%+%-]+<[%+%-]+%]>)([%+%-]+)" "%2%1")
    (string.gsub "(<<[%+%-]+%[>>[%+%-]+<<[%+%-]+%]>>)([%+%-]+)" "%2%1")
    (optimize)
    (string.gsub "([%+%-]+)(>>[%+%-]+%[<<[%+%-]+>>[%+%-]+%]<<)" "%2%1")
    (string.gsub "([%+%-]+)(>[%+%-]+%[<[%+%-]+>[%+%-]+%]<)" "%2%1")
    (string.gsub "([%+%-]+)(<[%+%-]+%[>[%+%-]+<[%+%-]+%]>)" "%2%1")
    (string.gsub "([%+%-]+)(<<[%+%-]+%[>>[%+%-]+<<[%+%-]+%]>>)" "%2%1")
    (optimize)))

(λ _optimize-fennel [code ?steps]
  "Remove useless combinations of brainfuck commands from `code`."
  (fn optimize [code ?steps]
    (var last-length 0)
    (faccumulate [result code
                  _ 1 (or ?steps 100)
                  &until (= last-length (length result))]
      (do
        (set last-length (length result))
        (-> result
          (string.gsub "[%+%-]+%[%-%]" "[-]")
          (string.gsub "%[%[%-%]%]" "[-]")
          (string.gsub "<>" "")
          (string.gsub "><" "")
          (string.gsub "%+%-" "")
          (string.gsub "%-%+" "")
          (string.gsub "%]%[%-%]" "]")))))

  (-> code ; TODO improve this
    (optimize ?steps)
    (string.gsub "(>>[%+%-]+%[<<[%+%-]+>>[%+%-]+%]<<)([%+%-]+)" "%2%1")
    (string.gsub "(>[%+%-]+%[<[%+%-]+>[%+%-]+%]<)([%+%-]+)" "%2%1")
    (string.gsub "(<[%+%-]+%[>[%+%-]+<[%+%-]+%]>)([%+%-]+)" "%2%1")
    (string.gsub "(<<[%+%-]+%[>>[%+%-]+<<[%+%-]+%]>>)([%+%-]+)" "%2%1")
    (optimize ?steps)
    (string.gsub "([%+%-]+)(>>[%+%-]+%[<<[%+%-]+>>[%+%-]+%]<<)" "%2%1")
    (string.gsub "([%+%-]+)(>[%+%-]+%[<[%+%-]+>[%+%-]+%]<)" "%2%1")
    (string.gsub "([%+%-]+)(<[%+%-]+%[>[%+%-]+<[%+%-]+%]>)" "%2%1")
    (string.gsub "([%+%-]+)(<<[%+%-]+%[>>[%+%-]+<<[%+%-]+%]>>)" "%2%1")
    (optimize ?steps)))

(λ bf.optimize [code ?steps]
  "Remove useless combinations of brainfuck commands from `code`.
   This function replaces itself with _optimize-cpp or _optimize-fennel."
  (if (pcall #(require :optimize)) ; is the optimize c++ module available ?
    (tset bf :optimize _optimize-cpp)
    (tset bf :optimize _optimize-fennel))
  (bf.optimize code ?steps))

(λ bf.optimize2 [code ?steps]
  "Remove useless combinations of brainfuck commands from `code`.
   More aggressive version of `bf.optimize`."
  (var last-length 0)
  (faccumulate [result (bf.optimize code ?steps)
                _ 1 (or ?steps 100)
                &until (= last-length (length result))]
    (do
      (set last-length (length result))
      (-> result
        (string.gsub "[%+%-]+," ",")
        (string.gsub "[<>%+%-]+$" "")
        (string.gsub "^[<>]+" "")
        (string.gsub "^%[%-%]+" "")))))

(λ bf.pgo [code]
  "Profile guided optimization: run code and remove all instructions that are not executed.
   `,` is assumed to never change a cell."
  (fn generate-profile [code]
    (let [luacode
          (faccumulate [luacode "ptr = 1\ndata={}\nprofile={}\n"
                        i 1 (length code)]
            (..
              luacode
              (->
                (match (string.sub code i i)
                  "[" "while (data[ptr] or 0) ~= 0 do\n%s\n"
                  "]" "%s\nend\n"
                  "<" "ptr = ptr - 1\n%s\n"
                  ">" "ptr = ptr + 1\n%s\n"
                  "+" "data[ptr] = ((data[ptr] or 0) + 1) %% 256\n%s\n"
                  "-" "data[ptr] = ((data[ptr] or 0) - 1) %% 256\n%s\n"
                  _   "%s\n")
                (string.format (.. "profile[" i "] = true")))))]
      ((load (.. luacode "\nreturn profile")))))
  (let [profile (generate-profile code)]
    (faccumulate [optimized-code ""
                  i 1 (length code)]
      (if (. profile i)
        (.. optimized-code (string.sub code i i))
        optimized-code))))

(λ bf.mirror [& code]
  "Swap `<` and `>`."
  (let [code (table.concat code)
        code (string.gsub code "." {:< :> :> :<})]
    code))

(λ bf.comment [...]
  "Make `str` safe to include in brainfuck code as an inline comment."
  (let [str (string.gsub
              (table.concat [...] " ")
              "."
              {">" "＞"
               "<" "＜"
               "[" "［"
               "]" "］"
               "," "，"
               "." "．"
               "+" "＋"
               "-" "－"
               "#" "＃"})]
    str))

(λ bf.commentln [...]
  "Make `str` safe to include in brainfuck code as a comment."
  (..
    "\n"
    (bf.comment (table.concat [...] "\n"))
    "\n"))

(λ bf.format [...]
  "A simple brainfuck formatter."
  (let [trim         #(pick-values 1 (-> $ (string.gsub "^%s*" "") (string.gsub "%s*$" "")))
        count-parens #(let [(_ opening) ($:gsub "%[" "[") (_ closing) ($:gsub "%]" "]")] (- opening closing))
        code         (.. (trim (table.concat [...] "\n")) "\n")
        lines        (icollect [line (string.gmatch code "[^\n]*\n")] (trim line))
        indents      []
        indent-str   "  "
        max-length   120]
    ;; calculate the indentation of each line
    (accumulate [sum 0 _ line (ipairs lines)]
      (do
        (table.insert indents sum)
        (+ sum (count-parens line))))
    ;; indent and join all lines
    (table.concat
      (fcollect [i 1 (length lines)]
        (let [line (.. (string.rep indent-str (. indents i)) (. lines i))]
          (if (> (length line) max-length)
            ;; split long lines
            (table.concat
              (icollect [part (string.gmatch ; TODO use a better way to split a line
                                (. lines i)
                                (string.rep
                                  ".?"
                                  (- max-length
                                     (* (length indent-str)
                                        (. indents i)))))]
                (.. (string.rep indent-str (. indents i)) part))
              "\n")
            line)))
      "\n")))



(λ bf.digits\ [?+1]
  "Creates a string containing the digits of the currrent cell as a decimal number.
   - before: `[x], 0, 0, 0, …`
   - after: `[x], 0, ones, tens, hundreds, [0]`
   If `?+1` is true, each digit will be stored as digit+1 (i.e. 0→1, 9→10)."
  (..
    (bf.at 1 (bf.zero))
    (bf.at 2 (bf.zero) "+")
    (bf.at 3 (bf.zero) "+")
    ">>"
    (bf.loop
      ">"
      (bf.loop
        "-<-"
        (bf.at -2
          (bf.add 2 1))
        ">")
      ;; prepare division by 10
      "++++++++++"
      ">[-]+>[-]>[-]>[-]<<<<<"
      (bf.divmod\!)
      ;; move results
      ">>" (if ?+1 "+" "") (bf.add! -2)
      (bf.ptr -1) (bf.zero)
      (bf.at 2
        (bf.add! -2)))))

(λ _generic-case [inc-fn temp0 temp0-init ?temp1 args body-zero]
  "This function is used to implement both `bf.case!` and `bf.case2!`.
   Do not use this directly."
  (fn _case [initial args]
    (let [[value body & args] args]
      (if
        ;; string: convert to number
        (= :string (type value))
        (do
          (table.insert args 1 body)
          (table.insert args 1 (string.byte value 1 1))
          (_case initial args))

        (..
          (inc-fn (- initial value) ?temp1)
          (bf.loop
            (if (>= (length args) 2)
              (_case value args) ; next case
              (..                ; default case
                (if (>= (length args) 1) ; is there a default case?
                  (bf.zero) ; → [[-]>[…[-]]<]
                  "-")      ; → [->[-]<]
                (bf.at temp0
                  (bf.loop
                    (if (>= (length args) 1)
                      (. args 1)
                      "")
                    (or body-zero ""))))))
          (if body
            (bf.at temp0
              (bf.loop
                body
                (or body-zero "")))
            "")))))
  (..
    ;; set temp0
    (if temp0-init
      (bf.at temp0
        (bf.zero)
        (inc-fn temp0-init ?temp1))
      "")

    (_case 0 args)))

(λ _build-case-args [inc-fn temp0 ?temp1 ...]
  "This function generates the `args` for `_generic-case`.
   Do not use this directly."
  (let [result []]
    (var init 1)
    (var body-zero (bf.zero))

    ;; iterate over value+code pairs and fill `result`
    (for [i 1 (length [...]) 2]
      (if
        ;; value is :init : set `temp0-init` of `_generic_case`
        (= :init (. [...] i))
        (set init (. [...] (+ 1 i)))

        ;; value is :zero : set `body-zero` of `_generic_case`
        (= :zero (. [...] i))
        (set body-zero (. [...] (+ 1 i)))

        ;; value is a table:
        ;; transform '[1 2 3] :foo' into '1 :foo 2 false 3 false'
        (= :table (type (. [...] i)))
        (do
          (table.insert result (+ 1 (length result)) (. [...] i 1))
          (table.insert result (+ 1 (length result)) (. [...] (+ 1 i)))
          (for [j 2 (length (. [...] i))]
            (table.insert result (+ 1 (length result)) (. [...] i j))
            (table.insert result (+ 1 (length result)) false)))

        ;; else
        (do
          (table.insert result (+ 1 (length result)) (. [...] i))
          (table.insert result (+ 1 (length result)) (. [...] (+ 1 i))))))

    (_generic-case inc-fn temp0 init ?temp1 result body-zero)))

(λ bf.case! [temp ...]
  "A switch-case-like construct.
   Takes an arbitrary number of value+code pairs and an optional default case.
   The code will be run at `temp`."
  (_build-case-args bf.inc temp :nil ...))

(λ bf.case2! [temp0 temp1 ...]
  "A switch-case-like construct.
   Takes an arbitrary number of value+code pairs and an optional default case.
   The code will be run at `temp0`."
  (_build-case-args bf.inc2 temp0 temp1 ...))

(fn bf.optimize-parms [func parms ?progress ?logfile]
  "Optimize the independent parameters `parms` of the function `func`.
   The goal is to find the parameters producing the shortest result of `func`.
   The parameters should not influence each other and must be given as a table of
   tables, each containing a minimum and maximum value, e.g. `[[1 100] [0 255]]`.
   If `?progress` is true, print the progress to stderr.
   If `?logfile` is a filename, a Julia script producing a plot of the result
   length is generated."
  (let [parms-count (length parms)
        current-parms
        (fcollect [i 1 parms-count]
          (. parms i 1))
        optimal-parms []
        logfile (if ?logfile (io.open ?logfile :w) nil)]

    (when logfile
      (: logfile :write "using Plots\nlengths = [\n"))

    ;; for each parameter
    (for [i 1 parms-count]
      (var optimal-value nil)
      (var optimal-length (/ 1 0))

      (when logfile
        (: logfile :write "[\n"))
      ;; for minimal to maximal value
      (for [v (. parms i 1) (. parms i 2)]
        (when ?progress
          (io.stderr:write "\roptimizing parameter " i " ... " v))
        (tset current-parms i v)

        ;; get length for current parms
        (let [current-length (length (func current-parms))]
          (when logfile
            (: logfile :write current-length ","))
          (when (< current-length optimal-length)
            (set optimal-length current-length)
            (set optimal-value v))))

      ;; reset current-parms, store optimal value
      (tset current-parms i (. parms i 1))
      (tset optimal-parms i optimal-value)
      (when ?progress
        (io.stderr:write " → " optimal-value "\n"))
      (when logfile
        (: logfile :write "],\n")))

    (when logfile
      (: logfile :write (.. "]\np = plot(lengths)\nsavefig(\"" ?logfile ".svg\")\n")))

    optimal-parms))

(λ bf.sample [func n ?logfile]
  "Call `func` `n` times and return the shortest result.
   Optionally write the lengths of all results to `?logfile`."
  (let [logfile (and ?logfile (io.open ?logfile :w))
        first-result (func)

        _ (when logfile
            (: logfile :write (.. (length first-result) "\n")))

        shortest-result
        (faccumulate [shortest-result first-result
                      _ 1 (- n 1)]
          (let [current-result (func)]
            (when logfile
              (: logfile :write (.. (length current-result) "\n")))
            (if (< (length current-result) (length shortest-result))
              current-result
              shortest-result)))]

    (when logfile
      (io.close logfile))
    shortest-result))

"# Bitwise operators"

(λ bf.bnot\! []
  "bitwise not
   - before: `[x] 0`
   - after:  `[0] result`"
  "+[->-<]")

(λ bf.shiftl\! []
  "Bit shift current cell left by one = multiply by 2.
   - before: `[x] 0`
   - after:  `[0] x>>1`"
  "[->++<]")

(λ bf.rotatel\! [?distance]
  "Rotate current cell left by `?distance` bits, the default is 1.
   If ??distance is nil or 1:
   - before: `[x] 0 0 0 0`
   - after:  `[result] 0 0 0 0`
   else:
   - before: `[x] 0 0 0 0 0`
   - after:  `[result] 0 0 0 0 0`"
  (if (or (= nil ?distance) (= 1 ?distance))
    (..
      (bf.add! 4) ;; [0] 0 0 0 x
      (bf.at 4
        (bf.loop
          (bf.at -4 (bf.double "++"))
          "-"))   ;; [x<<1] 0 0 carry 0
      (bf.at 3 (bf.add! -3)))
    (..
      (bf.at 5
        (bf.inc ?distance)
        (bf.loop
          (bf.at -5 (bf.rotatel\!))
          "-")))))

(λ bf.rotater\! [?distance]
  "Rotate current cell right by `?distance` bits, the default is 1.
   - before: `[x] 0 0 0 0 0`
   - after:  `[result] 0 0 0 0 0`"
  (if (= nil ?distance)
    (bf.rotater\! 1)
    (..
      (bf.at 5
        (bf.inc (- 8 ?distance))
        (bf.loop
          (bf.at -5 (bf.rotatel\!))
          "-")))))

(λ bf.popcount\! []
  "Population count, count the number of 1s in the binary representation of the current cell.
   - before: `[x] 0 0 0 0 0 0`
   - after:  `[0] 0 0 0 result 0 0`"
  (bf.at 6
    (bf.inc 8)
    (bf.loop
      ;; x = x * 2
      (bf.at -6 (bf.mov 5 1)) ; copy x
      (bf.at -1 ; add x to x
        (bf.loop
          (bf.at -5 (bf.double "+"))
          "-"))
      ;; add carry bit to result
      (bf.at -3 (bf.add! 1))
      "-")))

"# Double precision functions (16-bit)"
(set bf.D {})

(λ bf.double [...]
  "Double the precision of the interpreter.
   Each 16-bit cell is stored using 4 8-bit cells:
   low reserved reserved high
   ^ptr
    "
  (let [code (bf.optimize (table.concat [...]))]
    (faccumulate [result ""
                  i 1 (length code)]
      (..
        result
        (match (string.sub code i i)
          ">" ">>>>"
          "<" "<<<<"
          "+" ">+<+[>-]>[->>+<]<<"
          "-" ">+<[>-]>[->>-<]<<-"
          "[" ">+<[>-]>[->+>[<-]<[<]>[-<+>]]<-[+<"
          "]" ">+<[>-]>[->+>[<-]<[<]>[-<+>]]<-]<"
          _ (string.sub code i i))))))

(λ bf.D.loop [...]
  "A doubled loop: [...]"
  (..
    (bf.double "[")
    (table.concat [...] "")
    (bf.double "]")))

(λ bf.D.ptr [distance]
  "Doubled version `bf.ptr`: move ptr 4 * `distance`."
  (bf.ptr (* 4 distance)))

(λ bf.D.at [distance ...]
  "Move pointer by `distance`, insert body, move back"
  (bf.at (* 4 distance)
    (table.concat [...] "")))

(λ bf.D.zero []
  "Doubled version `bf.zero`."
  "[-]>>>[-]<<<")

(λ bf.D.add! [to]
  "Doubled version of `bf.add!`."
  (bf.double (bf.add! to)))

(λ bf.D.sub! [to]
  "Doubled version of `bf.sub!`."
  (bf.double (bf.sub! to)))

(λ bf.D.multiply-add! [times to]
  "Doubled version of `bf.multiply-add!`."
  (bf.double (bf.multiply-add! times to)))

(λ bf.D.mov! [to]
  "Doubled version `bf.mov!`. TODO optimize"
  (..
    (bf.mov! (* 4 to))
    (bf.at 3
      (bf.mov! (* 4 to)))))

(λ bf.D.mov [to ?init]
  "Doubled version `bf.mov`.
  `to` must be manually set to 0, unless `?init` is true."
  (..
    (bf.mov (* 4 to) 1 ?init)
    (bf.at 3
      (bf.mov (* 4 to) -1 ?init))))

(λ bf.D.set [value]
  "Set a doubled cell to `value`, the initial value must be 0."
  (let [low (% value 256)
        high (math.tointeger (/ (- value low) 256))]
    (bf.inc2-2 low high 3 1)))

(λ bf.D.zero?! []
  "Check if a doubled cell is zero."
  (..
    "[[-]>+<]"
    ">>>[[-]<<+>>]<<<"
    ">>+<<"
    ">[[-]>-<]<"
    ">>[-<<+>>]<<"))

(λ bf.D.+3 []
  "Increment a doubled cell by 3."
  "+++[>+>+<<-]>>[<<+>>-]+<[-[-[[-]>-<]]]>[>+<-]<<")

(λ bf.D.divmod\! [?mod+1]
  "Current cell divided/modulo by the next cell to the right.
   Uses 5 cells to the right of the current cell, cells must be initialized as shown:
   - Before: `>n d 1 0 0 0`
   - After:  `>0 d-n%d n%d n/d 0 0`
   If `?mod+1` is true, `n%d` is `n%d+1` instead."
  (..
    (bf.double "[->-[>+>>]>[")
    (bf.D.mov! -1)
    (bf.double "+>+>>]<<<<<]")
    (if ?mod+1
      ""
      (bf.double ">>-<<"))))

(λ bf.D.divmod2\! [?mod+1]
  "Current cell divided/modulo by the next cell to the right. Optimized for d<256.
   Uses 5 cells to the right of the current cell, cells must be initialized as shown:
   - Before: `>n d 1 0 0 0`
   - After:  `>0 d-n%d n%d n/d 0 0`
   If `?mod+1` is true, `n%d` is `n%d+1` instead."
  (..
    (bf.double "[->")
    "-"
    (bf.loop
      (bf.double ">+>>"))
    (bf.double ">[")
    (bf.D.mov! -1)
    (bf.double "+>+>>]<<<<<]")
    (if ?mod+1
      ""
      (bf.double ">>-<<"))))

(λ bf.D.print-cell\ []
  "Print the value of the current doubled cell.
   Based on: https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_for_ANY_sized_cell_(eg_8bit,_100000bit_etc)"
  (..
    (bf.D.ptr 1) (bf.D.zero)
    (bf.D.ptr 1) (bf.D.zero) "+"
    (bf.D.ptr 1) (bf.D.zero) "+"
    (bf.D.ptr -1)
    (bf.D.loop ; using a normal loop here works for some numbers
      (bf.D.ptr 1)
      (bf.loop
        "-<<<<-<<<<<<<<"
        (bf.D.mov 2)
        (bf.D.ptr 3))
      (bf.inc 10)
      (bf.D.ptr 1) (bf.D.zero) "+"
      (bf.D.ptr 1) (bf.D.zero)
      (bf.D.ptr 1) (bf.D.zero)
      (bf.D.ptr 1) (bf.D.zero)
      (bf.double "<<<<<[->")
      "-[>>>>+>>>>>>>>]"
      (bf.D.ptr 1)
      (bf.loop
        "[-<<<<+>>>>]+"
        (bf.double ">+>>"))
      (bf.double "<<<<<]>>")
      "-[-<<<<<<<<+>>>>>>>>]<<<<"
      ;; add 48 to a digit to convert it to ASCII
      "[-]++++++++[-<<<<++++++>>>>]"
      (bf.D.at 2
        (bf.D.mov! -2)))
    (bf.D.ptr -1)
    ;; print all digits
    "[.[-]<<<<]<<<<"))

(λ bf.D.digits\ [?+1]
  "Doubled version of `bf.D.digits\\`
   - before: `{[x], 0, 0, x}, 0, 0, 0, …`
   - after: `{x, 0, 0, x}, {0, 0, 0, 0}, ones, tens, hundreds, …, [0]`
   If `?+1` is true, each digit will be stored as digit+1 (i.e. 0→1, 9→10)."
  (..
    (bf.D.at 1 (bf.D.zero))
    (bf.D.at 2 (bf.D.zero) "+")
    (bf.D.at 3 (bf.D.zero) "+")
    (bf.D.ptr 2)
    (bf.double "[")
      (bf.D.ptr 1)
      (bf.double "[")
        (bf.double "-<-")
        (bf.D.at -2
          (bf.D.mov 2))
        (bf.D.ptr 1)
        (bf.double "]")
      ;; prepare division by 10
      "++++++++++"
      (bf.D.ptr 1) (bf.D.zero) "+"
      (bf.D.ptr 1) (bf.D.zero)
      (bf.D.ptr 1) (bf.D.zero)
      (bf.D.ptr 1) (bf.D.zero)
      (bf.D.ptr -5)
      ;; division
      (bf.D.divmod\! true)
      ;; move results
      (bf.D.ptr 2) (if ?+1 "" "-") (bf.D.add! -2)
      (bf.D.ptr -1) (bf.D.zero)
      (bf.at 8 (bf.add! -11))
      (bf.at 11 (bf.add! -11))
      "<<<"
      (bf.double "]")))

(λ bf.D.popcount\! []
  "Population count of a doubled cell, count the number of 1s in the binary representation of the current cell.
   - before: `[low] 0 0 high 0 0 0 0 0 0`
   - after:  `[0] 0 0 0 result 0 0 0 0 0`"
  (..
    (bf.at 3 (bf.popcount\!))
    (bf.popcount\!)
    (bf.at 7 (bf.add! -3))))

(λ bf.D.read-int [delimiter temp0 temp1 Dtemp2 Dtemp3]
  "Read an integer delimited by `delimiter`.
   Dtemp2 and Dtemp3 must be undoubled pointers to doubled cells.
   All temp cells must be initialized with 0, the result is placed in Dtemp3."
  (..
    "+"
    (bf.loop
      ","
      (bf.mov temp0 temp1) ; copy read char to temp0
      (bf.at temp0
        (bf.case! (- temp1 temp0)
          delimiter ; delimiter: zero read char
          (bf.at (- 0 temp1) (bf.zero))

          ;; else: digit
          (..
            (bf.at (- Dtemp3 temp1)                         ; Dtemp2 = Dtemp3 × 10; Dtemp3 = 0
              (bf.double "[-") (bf.at (- Dtemp2 Dtemp3) (bf.double (bf.inc 10))) (bf.double "]"))
            (bf.at (- 0 temp1)
              (bf.inc2 -48 Dtemp3)
              (bf.loop "-" (bf.at Dtemp2 (bf.double "+")))) ; Dtemp2 += read char - 48
            (bf.at (- Dtemp2 temp1)                         ; Dtemp3 = Dtemp2; Dtemp2 = 0
              (bf.double "[-") (bf.at (- Dtemp3 Dtemp2) (bf.double "+")) (bf.double "]"))
            (bf.at (- 0 temp1) "+")))))))                   ; set temp1 to 1 to continue the loop

"# Triple precision functions (24-bit)"

(λ bf.triple [...]
  "Triple the precision of the interpreter.
   Each 24-bit cell is stored using 7 8-bit cells:
   a reserved reserved b reserved reserved c
   ^ptr

   value = a + 256*b + 65536*c"
  (let [code (bf.optimize (table.concat [...]))]
    (faccumulate [result ""
                  i 1 (length code)]
      (..
        result
        (match (string.sub code i i)
          ">" ">>>>>>>"
          "<" "<<<<<<<"
          "+" ">+<+[>-]>[->>>+<+[>-]>[->>+<]<<<]<<"
          "-" ">+<[>-]>[->>>+<[>-]>[->>-<]<<-<]<<-"
          "[" ">>[-]<<[>>+<]>[<]>>[>>+<]>[<]>[-<<<+>>>]>[<<+>]<[>]<[-<<+>>]<<[[-]<<"
          "]" "[>>+<]>[<]>>[>>+<]>[<]>[-<<<+>>>]>[<<+>]<[>]<[-<<+>>]<<]<<"
          _ (string.sub code i i))))))

"# Quadruple precision functions (32-bit)"
(set bf.Q {})

(λ bf.quadruple [...]
  "Quadruple the precision of the interpreter.
   Cell layout (little endian):
   `(0) [a] b c d (0)`
   The sorrounding zeros are required, but they can overlap between quadrupled cells."
  (let [code (bf.optimize (table.concat [...]))]
    (faccumulate [result ""
                  i 1 (length code)]
      (..
        result
        (match (string.sub code i i)
          ">" ">>>>>"
          "<" "<<<<<"
          "+" "+[<+>>>>>+<<<<-]<[>+<-]+>>>>>[<<<<<->>>>>[-]]<<<<<[->>+[<<+>>>>>+<<<-]<<[>>+<<-]+>>>>>[<<<<<->>>>>[-]]<<<<<[->>>+[<<<+>>>>>+<<-]<<<[>>>+<<<-]+>>>>>[<<<<<->>>>>[-]]<<<<<[->>>>+<<<<]]]>"
          "-" "[<+>>>>>+<<<<-]<[>+<-]+>>>>>[<<<<<->>>>>[-]]<<<<<[->>[<<+>>>>>+<<<-]<<[>>+<<-]+>>>>>[<<<<<->>>>>[-]]<<<<<[->>>[<<<+>>>>>+<<-]<<<[>>>+<<<-]+>>>>>[<<<<<->>>>>[-]]<<<<<[->>>>-<<<<]>>>-<<<]>>-<<]>-"
          "[" "[>>>>+>>>>>+<<<<<<<<<-]>>>>>>>>>[<<<<<<<<<+>>>>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<<<[>>>+>>>>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<<[>>+>>>>>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<[>+>>>>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<<<<<[[-]>"
          "]" "[>>>>+>>>>>+<<<<<<<<<-]>>>>>>>>>[<<<<<<<<<+>>>>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<<<[>>>+>>>>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<<[>>+>>>>>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<[>+>>>>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<<<[[-]<<<<<+>>>>>]<<<<<]>"
          _ (string.sub code i i))))))

(λ bf.Q.loop [...]
  "A quadrupled loop: [...]"
  (..
    (bf.quadruple "[")
    (table.concat [...] "")
    (bf.quadruple "]")))

(λ bf.Q.ptr [distance]
  "Quadrupled version `bf.ptr`: move ptr 5 * `distance`."
  (bf.ptr (* 5 distance)))

(λ bf.Q.at [distance ...]
  "Move pointer by `distance` * 5, insert body, move back"
  (bf.at (* 5 distance)
    (table.concat [...] "")))

(λ bf.Q.zero []
  "Quadrupled version `bf.zero`."
  "[-]>[-]>[-]>[-]<<<")

(λ bf.Q.mov [to ?init]
  "Quadrupled version `bf.mov`.
  `to` must be manually set to 0, unless `?init` is true."
  (..
    (bf.mov (* 5 to) 4 ?init)
    (bf.at 1
      (bf.mov (* 5 to) 3 ?init))
    (bf.at 2
      (bf.mov (* 5 to) 2 ?init))
    (bf.at 3
      (bf.mov (* 5 to) 1 ?init))))

(λ bf.Q.mov! [to]
  "Quadrupled version `bf.mov!`."
  (bf.at [0 (bf.mov! (* 5 to))
          1 (bf.mov! (* 5 to))
          2 (bf.mov! (* 5 to))
          3 (bf.mov! (* 5 to))]))

(λ bf.Q.print-cell\ []
  "Print the value of the current quadrupled cell.
   Based on: https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_for_ANY_sized_cell_(eg_8bit,_100000bit_etc)"
  (..
    (bf.Q.ptr 1) (bf.Q.zero)
    (bf.Q.ptr 1) (bf.Q.zero) "+"
    (bf.Q.ptr 1) (bf.Q.zero) "+"
    (bf.Q.ptr -1)
    (bf.Q.loop ; using a normal loop here works for some numbers
      (bf.Q.ptr 1)
      (bf.loop
        "-<<<<<-<<<<<<<<<<"
        (bf.Q.mov 2)
        (bf.Q.ptr 3))
      (bf.inc 10)
      (bf.Q.ptr 1) (bf.Q.zero) "+"
      (bf.Q.ptr 1) (bf.Q.zero)
      (bf.Q.ptr 1) (bf.Q.zero)
      (bf.Q.ptr 1) (bf.Q.zero)
      (bf.quadruple "<<<<<[->")
      "-[>>>>>+>>>>>>>>>>]"
      (bf.Q.ptr 1)
      (bf.loop
        "[-<<<<<+>>>>>]+"
        (bf.quadruple ">+>>"))
      (bf.quadruple "<<<<<]>>")
      "-[-<<<<<<<<<<+>>>>>>>>>>]<<<<<"
      ;; add 48 to a digit to convert it to ASCII
      "[-]++++++++[-<<<<<++++++>>>>>]"
      (bf.Q.at 2
        (bf.Q.mov! -2)))
    (bf.Q.ptr -1)
    ;; print all digits
    "[.[-]<<<<<]<<<<<"))

(λ bf.read-int [delimiter temp0 temp1 temp2 temp3]
  "Read an integer delimited by `delimiter`.
   All temp cells must be initialized with 0, the result is placed in temp3."
  (..
    "+"
    (bf.loop
      ","
      (bf.mov temp0 temp1) ; copy read char to temp0
      (bf.at temp0
        (bf.case! (- temp1 temp0)
          delimiter ; delimiter: zero read char
          (bf.at (- 0 temp1) (bf.zero))

          ;; else: digit
          (..
            (bf.at (- temp3 temp1)
              (bf.multiply-add! 10 (- temp2 temp3))) ; temp2 = temp3 × 10; temp3 = 0
            (bf.at (- 0 temp1)
              (bf.inc2 -48 temp3)
              (bf.add! temp2))                       ; temp2 += read char - 48
            (bf.at (- temp2 temp1)
              (bf.add! (- temp3 temp2)))             ; temp3 = temp2; temp2 = 0
            (bf.at (- 0 temp1) "+")))))))            ; set temp1 to 1 to continue the loop

(λ bf.read-list [move separator terminator ?no-initial-read]
  "Read a list of integers, separated by `separator` and terminated by `terminator`.
   The integers are placed `move` cells apart in memory.
   Set `?no-initial-read` to true, if the current cell contains the first character of the sequence."
  (let [move2 (* 2 move)
        move3 (* 3 move)
        terminator (string.byte terminator 1 1)]
    (..
      (if ?no-initial-read "" ",")
      (bf.inc (- terminator))
      (bf.loop
        (bf.inc terminator)
        (bf.mov move move2)
        (bf.at move
          (bf.case2! move move2
            separator
            (..
              (bf.at (- move2) (bf.zero))
              ">")

            ;; digit
            (..
              (bf.at (- move3)
                (bf.multiply-add! 10 move))
              (bf.at (- move2)
                (bf.inc2 -48 (- move))
                (bf.add! (- move))))))
        ","
        (bf.inc (- terminator))))))

(set bf.array1 {})
"# Array1 functions
These functions operate on arrays that use a single cell per value.
Zero is not a valid value inside the array, because the array is delimited by zeros on both ends."

(λ bf.array1.shiftr [?distance]
  "Shift array right by `?distance` cells (default is one).
   - before: `0, array, [0], 0`
   - after:  `0, [0], array, 0`"
  (let [?distance (if ?distance ?distance 1)]
    (assert (>= ?distance 1) "shiftr: distance must be >= 1")
    (..
      "<[[-"
      (bf.at ?distance "+")
      "]<]"
      (bf.ptr ?distance))))

(λ bf.array1.shiftl [?distance]
  "Shift array left by `?distance` cells (default is one).
   - before: `0, [0], array, 0`
   - after:  `0, array, [0], 0`"
  (let [?distance (if ?distance ?distance 1)]
    (assert (>= ?distance 1) "shiftl: distance must be >= 1")
    (..
      ">[[-"
      (bf.at (- ?distance) "+")
      "]>]"
      (bf.ptr (- ?distance)))))

(λ bf.array1.length []
  "Get the length of an array.
   - before: `0, array, [0], 0, 0`
   - after:  `0, array, [0], length, 0`"
  "<[[->+<]>[>]>+<<[<]<]>>[[-<+>]>]>[-<+>]<<")

(λ bf.array1.reverse []
  "Reverse an array.
   - before: `0, array, [0], 0, 0`
   - after:  `0, array, [0], 0, 0`"
  "<[[->>[>]>+<<[<]<]>>[>]>[-<+>]<[<]>[[-<+>]>]<<[<]<]>>[[-<+>]>]<")

(λ bf.array1.get []
  "Get an element of an array, the index is 0 based.
   - before: `0, 0, array, [0], index, 0`
   - after:  `0, 0, array, [0], result, 0`"
  (..
    ">+[<<[<]>[-<+>]>[>]>-]" ; while index: move first cell of array left
    "<<[<]<" ; move to cell left of the created gap
    "[>>[>]>+>+<<<[<]<-]" ; move cell two times
    ">>[>]>>[<<<[<]<+>>[>]>>-]" ; restore cell
    "<<<[<]" ; go to gap in array
    (bf.array1.shiftr)
    ">[>]"))

(λ bf.array1.set []
  "Set an element of an array to value, the index is 0 based.
   - before: `0, 0, array, [0], index, value`
   - after:  `0, 0, array, [0], 0, 0`"
  (..
    ">+[<<[<]>[-<+>]>[>]>-]" ; while index: move first cell of array left
    "<<[<]<" ; move to cell left of the created gap
    "[-]>>[>]>>[-<<<[<]<+>>[>]>>]" ; move value to current cell
    "<<<[<]" ; go to gap in array
    (bf.array1.shiftr)
    ">[>]"))

(λ bf.array1.copyr [distance]
  "Copy an array `distance` cells to the right.
   - before: `0, 0, array, [0]`
   - after: `0, 0, array, [0], ..., 0, array, 0`"
  (assert (>= distance 1) "copyr: distance must be >= 1")
  (..
    "<[<]>" ; move to first element
    (bf.loop
      ;; copy element to end of copy and to -2
      "[>]" (bf.ptr distance) "[>]+[<]" (bf.ptr (- distance)) "[<]>-<<+>>"
      (bf.loop
        "[>]" (bf.ptr distance) "[>]<+[<]" (bf.ptr (- distance)) "[<]>-<<+>>")

      ">") ; next element
    "<<<[[->>+<<]<]>>>[>]")) ; shift left copy right by 2

(λ bf.array1.copyl [distance]
  "Copy an array `distance` cells to the left.
   - before: `0, array, [0], 0`
   - after: `0, array, 0, ..., 0, array, [0], 0`"
  (assert (>= distance 1) "copyl: distance must be >= 1")
  (..
    "<" ; move to last element
    (bf.loop
      ;; copy element to end of copy and to -2
      "[<]" (bf.ptr (- distance)) "[<]+[>]" (bf.ptr distance) "[>]<->>+<<"
      (bf.loop
        "[<]" (bf.ptr (- distance)) "[<]>+[>]" (bf.ptr distance) "[>]<->>+<<")

      "<") ; next element
    ">>>[[-<<+>>]>]<<<[>]")) ; shift right copy left by 2

(λ bf.array1.strcomparel! [str ?mode]
  "Compare array with `str`, deletes the array and places the result to the left.
   If `?mode` is 'not=' the result is the number of characters that are different,
   else the result is 1 if the array and string are equal, if not then 0.
   - before: `0, 0, array, [0]`
   - after: `[result], 0, 0, 0, ...`"
  (..
    "<[<]<[-]" (if (= ?mode :not=) "" "+") ">>[>]<" ; set result
    (faccumulate [r ""
                  i (length str) 1 -1]
      (.. r
          (bf.inc2 (- (str.byte str i i)) 1)
          ;; if not zero, zero current element and zero or inc result
          "[[-]<[<]<" (if (= ?mode :not=) "+" "[-]") ">>[>]]"
          "<")) ; next element
    "<"))

(λ bf.array1.strcomparer! [str ?mode]
  "Compare array with `str`, deletes the array and places the result to the right.
   If `?mode` is 'not=' the result is the number of characters that are different,
   else the result is 1 if the array and string are equal, if not then 0.
   - before: `[0], array, 0, 0`
   - after: `..., 0, 0, 0, [result]`"
  (..
    ">[>]>[-]" (if (= ?mode :not=) "" "+") "<<[<]>" ; set result
    (faccumulate [r ""
                  i 1 (length str)]
      (.. r
          (bf.inc2 (- (str.byte str i i)) -1)
          ;; if not zero, zero current element and zero or inc result
          "[[-]>[>]>" (if (= ?mode :not=) "+" "[-]") "<<[<]]"
          ">")) ; next element
    ">"))

(λ bf.array1.sort []
  "Sort array in place.
   - before: 0, 0, array, [0], 0, 0, 0, 0, 0, 0"
  (..
    (bf.at 6
      "+" ; set flag
      (bf.loop
        "-"
        "<<[<]<<<<<<" ; move to second last cell
        (bf.loop
          (bf.mov 3 2) ">" (bf.mov 1 3) ">>>" ; copy the last two elements: ... x y -- ... x y y x [0]
          "+<<[->[->]>[<<[-]>>->>]<<+<<]>>-<<" ; compare x y: ... x y y x [0] -- x y [0] (y<x ? x-y : 0) 0
          (bf.at 1 (bf.if "<+>") "+")
          (bf.loop ; if y<x
            "->-<<<" ; ... x y [1] 1 -- ... [x] y 0 0
            (bf.mov! 6)
            ">"
            (bf.mov! -1)
            ">>>>>[>]>[-]+<<[<]<<<") ; set flag
          (bf.at 1 ; else: x>=y
            (bf.loop
              (bf.at -2 (bf.mov! 5))
              "-"))
          "<<<")
        ">>>>>>" (bf.array1.shiftl 5) ">>"))))

(λ bf.array1.map [distance & code]
  "Map `code` over array in place:
   - before: `0, array, [0], 0
   - after: `0, array, [0], 0
  `code` is run in the following environment: `array, 0 * distance, [current element], array`"
  (..
    "<"
    (bf.loop
      (bf.add! distance)
      (bf.at distance
        (table.concat code))
      "<")
    (bf.ptr distance)
    (bf.array1.shiftl distance)))

(λ bf.array1.foldr [& code]
  "Right fold, places the result in the leftmost element of the array.
   - before: `0, array, [0]`
   - after: `[0], result, 0, …, 0`
  `code` is run in the following environment `array, [a], b, 0, …`, and must produce `array, [f(a,b)], 0, 0, …`"
  (..
    "<<"
    (bf.loop
      (table.concat code)
      "<")))

(λ bf.array1.foldl [& code]
  "Left fold, places the result in the rightmost element of the array.
   - before: `[0], array, 0`
   - after: `0, …, 0, result, [0]`
  `code` is run in the following environment `…, 0, a, [b], array`, and must produce `…, 0, 0, [f(a,b)], array`"
  (..
    ">>"
    (bf.loop
      (table.concat code)
      ">")))

(λ bf.array1.suml []
  "Sum all elements in the array, the result is placed in the leftmost element.
   - before: `0, array, [0]`
   - after: `[0], sum, 0, …, 0`"
  (bf.array1.foldr
    (bf.at 1
      (bf.add! -1))))

(λ bf.array1.sumr []
  "Sum all elements in the array, the result is placed in the rightmost element.
   - before: `[0], array, 0`
   - after: `0, …, 0, sum, [0]`"
  (bf.array1.foldl
    (bf.at -1
      (bf.add! 1))))


(set bf.arrayN {})
"# ArrayN functions
These functions operate on arrays where each value is `N` cells large and can contain zero.
Each value occupies N+1 cells: `…, 0, 0, 1, value*N, 1, value*N, 1, value*N, 0, 0, …`"

(λ bf.arrayN.shiftr [N ?distance]
  "Shift array right by `?distance` cells (default is one).
   - before: `0, array, [0], 0`
   - after:  `0, [0], array, 0`"
  (let [?distance (if ?distance ?distance 1)]
    (assert (>= ?distance 1) "shiftr: distance must be >= 1")
    (..
      (bf.ptr (- (+ 1 N)))
      (bf.loop
        (bf.at N
          (string.rep
            (.. (bf.add! ?distance) "<")
            (+ 1 N))))
      (bf.ptr ?distance))))

(λ bf.arrayN.shiftl [N ?distance]
  "Shift array left by `?distance` cells (default is one).
   - before: `0, [0], array, 0`
   - after:  `0, array, [0], 0`"
  (let [?distance (if ?distance ?distance 1)]
    (assert (>= ?distance 1) "shiftl: distance must be >= 1")
    (..
      ">"
      (bf.loop
        (string.rep
          (.. (bf.add! (- ?distance)) ">")
          (+ 1 N)))
      (bf.ptr (- (+ 1 N))))))

(λ bf.arrayN.split [N]
  "Split an array by inserting N+1 zeroed cells, the index is 0 based.
   - before: `0, 0, array, [0], index, 0`
   - after:  `array, 0*(N+1), array, [0], 0`"
  (..
    ">+"
    (bf.loop ; while index: move first cell of array left
      (bf.ptr (- (+ 2 N))) ; move to last element
      (bf.loop (bf.ptr (- (+ 1 N))))
      (bf.ptr (+ 1 N))     ; move to first element
      (string.rep          ; shift first element left
        (.. (bf.mov! (- (+ 1 N)) false) ">")
        (+ 1 N))
      (bf.loop (bf.ptr (+ 1 N))) ; move to index
      ">-")
    "<"))

(λ bf.arrayN.get [N]
  "Get an element of an array, the index is 0 based.
   - before: `0, 0, array, [0], index, 0`
   - after:  `0, 0, array, [0], 0*(N-1), result*N, 0`"
  (..
    (bf.arrayN.split N)
    ;; move to gap
    (bf.ptr (- (+ 1 N)))
    (bf.loop
      (bf.ptr (- (+ 1 N))))
    ;; copy all cells of the value
    (faccumulate [r "" i 1 N]
      (..
        r
        ;; copy cell inside the gap
        (bf.at (- i)
          (bf.mov (+ 1 i) 1))
        ;; move cell outside the gap
        (bf.at 1
          (bf.loop
            "-"
            (bf.ptr N)
            (bf.loop (bf.ptr (+ 1 N)))
            (bf.at (- (* 2 N) i) "+")
            (bf.ptr (- (+ 1 N)))
            (bf.loop (bf.ptr (- (+ 1 N))))
            ">"))
        ;; shift cell right
        (bf.at (- i)
          (bf.mov! (+ 1 N) false))))
    ;; shift value start right
    (bf.ptr (- N))
    "<" (bf.mov! (+ 1 N) false)
    ;; merge array parts
    (bf.arrayN.shiftr N (+ 1 N))
    (bf.ptr (+ 1 N))
    (bf.loop
      (bf.ptr (+ 1 N)))))

(λ bf.arrayN.set [N]
  "Get an element of an array, the index is 0 based.
   - before: `0, 0, array, [0], index, value*N`
   - after:  `0, 0, array, [0], 0, 0, …`"
  (..
    (bf.arrayN.split N)
    ;; move to gap
    (bf.ptr (- (+ 1 N)))
    (bf.loop
      (bf.ptr (- (+ 1 N))))
    ;; clear old value
    (string.rep "<[-]" N) "<"
    (bf.ptr (* 2 (+ 1 N)))
    (bf.loop
      (bf.ptr (+ 1 N)))
    ;; copy all cells of the value
    (faccumulate [r "" i 1 N]
      (..
        r
        (bf.at (+ 1 i)
          (bf.loop
            "-"
            (bf.ptr (- (+ 2 i N)))
            (bf.loop (bf.ptr (- (+ 1 N))))
            (bf.at (- (+ 1 (- N i))) "+")
            (bf.ptr (+ 1 N))
            (bf.loop (bf.ptr (+ 1 N)))
            (bf.ptr (+ 1 i))))))
    ;; move to gap
    (bf.ptr (- (+ 1 N)))
    (bf.loop
      (bf.ptr (- (+ 1 N))))
    ;; merge array parts
    (bf.arrayN.shiftr N (+ 1 N))
    (bf.ptr (+ 1 N))
    (bf.loop
      (bf.ptr (+ 1 N)))))

bf
