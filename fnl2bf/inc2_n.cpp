/*
This is a Lua module that loads the file inc2-n.csv, generated by
../constants/inc2-n.jl, and provides a Lua function to access the data.

No validation of the input data is performed and the parsing is not safely implemented to improve performance.
*/

#define INC2_N_CSV_PATH "../constants/inc2-n.csv"

#include <array>
#include <cstdint>
#include <fstream>
#include <limits>
#include <map>
#include <sstream>
#include <string>
#include <vector>

// read a uint8_t from in starting at i
uint8_t unsafe_stou_getline(int& i, const std::string& in)
{
    uint8_t result = 0;

    do {
        result = (result * 10) + (in[i] - '0');
        i++;
    } while (in[i] != ',');
    i++;

    return result;
}

// read an int8_t from in starting at i
int8_t unsafe_stoi_getline(int& i, const std::string& in)
{
    int8_t result = 0;
    bool is_negative = false;

    if (in[i] == '-') {
        is_negative = true;
        i++;
    }

    do {
        result = (result * 10) + (in[i] - '0');
        i++;
    } while (in[i] != ',');
    i++;

    return is_negative ? -result : result;
}

// calculate the cost of a solution
int cost(int8_t il, int8_t al, std::vector<std::array<int8_t, 2>>& all_i1_a1)
{
    int cost = 0;

    cost += il < 0 ? -il : il;
    cost += al < 0 ? -al : al;

    for(const std::array<int8_t, 2>& i1_a1 : all_i1_a1){
        cost += i1_a1[0] < 0 ? -i1_a1[0] : i1_a1[0];
        cost += i1_a1[1] < 0 ? -i1_a1[1] : i1_a1[1];
    }

    return cost;
}

// generate bf code to move the pointer by distance
void bf_ptr(std::stringstream& s, int distance){
    if(distance < 0){
        for(int i=0; i>distance; i--) s << '<';
    }else{
        for(int i=0; i<distance; i++) s << '>';
    }
}

// generate bf code to increment/decrement the cell at ptr by amount
void bf_inc(std::stringstream& s, int amount){
    if(amount < 0){
        for(int i=0; i>amount; i--) s << '-';
    }else{
        for(int i=0; i<amount; i++) s << '+';
    }
}

// generate the resulting brainfuck code
std::string build_bf(int8_t il, int8_t al, std::vector<std::array<int8_t, 2>>& all_i1_a1, std::vector<int>& positions, int loop_position){
    std::stringstream s;
    int ptr = 0;

    // i1
    for(size_t i = 0; i<positions.size(); i++){
        bf_ptr(s, positions[i] - ptr);
        ptr = positions[i];
        bf_inc(s, all_i1_a1[i][0]);
    }

    // il: start of loop
    bf_ptr(s, loop_position - ptr);
    ptr = loop_position;
    bf_inc(s, il);
    s << '[';

    // a1
    for(size_t i = 0; i<positions.size(); i++){
        bf_ptr(s, positions[i] - ptr);
        ptr = positions[i];
        bf_inc(s, all_i1_a1[i][1]);
    }

    // al
    bf_ptr(s, loop_position - ptr);
    ptr = loop_position;
    bf_inc(s, al);

    // end of loop
    s << ']';
    bf_ptr(s, -ptr);

    return s.str();
}

extern "C" {
#include <lauxlib.h>
#include <lua.h>

bool is_loaded = false;
std::array<std::vector<std::array<int8_t, 4>>, 256> inc2_n_factors; // <<<il,al,i1,a1>>, r>

// load inc2-n.csv into inc2_n_factors
int load(lua_State* L)
{
    if(is_loaded){
        return 0;
    }

    std::ifstream csv_file(INC2_N_CSV_PATH);
    std::string line;

    if (csv_file.fail()) {
        return luaL_error(L, "failed to open " INC2_N_CSV_PATH);
    }

    while (std::getline(csv_file, line)) {
        int i = 0;
        line += ',';

        uint8_t r = unsafe_stou_getline(i, line);

        int8_t il = unsafe_stoi_getline(i, line);
        int8_t al = unsafe_stoi_getline(i, line);
        int8_t i1 = unsafe_stoi_getline(i, line);
        int8_t a1 = unsafe_stoi_getline(i, line);

        inc2_n_factors[r].push_back(std::array<int8_t, 4>{il, al, i1, a1});
    }

    csv_file.close();
    is_loaded = true;
    return 0;
}

// get values from inc2_n_factors
int inc2_n(lua_State* L)
{
    load(L);

    // this functions requires two tables and a number
    luaL_checktype(L, 1, LUA_TTABLE);
    luaL_checktype(L, 2, LUA_TTABLE);

    std::vector<uint8_t> values;
    std::vector<int> positions;
    int loop_position = lua_tointeger(L, 3);

    // get values and positions from lua
    int n = luaL_len(L, 1);
    for (int i=1; i<=n; i++) {
        lua_geti(L, 1, i);
        values.push_back(lua_tointeger(L, -1));
    }

    n = luaL_len(L, 2);
    for (int i=1; i<=n; i++) {
        lua_geti(L, 2, i);
        positions.push_back(lua_tointeger(L, -1));
    }

    if(values.size() != positions.size()){
        return luaL_error(L, "the number of values/positions doesn't match");
    }

    // search all possible parameters to find the optimal parameters
    int8_t best_il = 0, best_al = 0;
    std::vector<std::array<int8_t, 2>> best_all_i1_a1;
    int best_cost = std::numeric_limits<int>::max();

    // TODO il and al should start at -20, this decreases the length in some cases but increases it in others. why?
    for(int8_t il=0; il<=20; il++){
        for(int8_t al=0; al<=20; al++){
            if(il == 0 && al==0) continue;

            bool possible = true;
            std::vector<std::array<int8_t, 2>> all_i1_a1;

            for(uint8_t value : values){
                bool this_value_possible = false;

                for(std::array<int8_t, 4>& this_r_il_al_i1_a1 : inc2_n_factors[value]){
                    if(this_r_il_al_i1_a1[0] == il && this_r_il_al_i1_a1[1] == al){
                        all_i1_a1.push_back(std::array<int8_t, 2>{this_r_il_al_i1_a1[2], this_r_il_al_i1_a1[3]});
                        this_value_possible = true;
                        break;
                    }
                }

                if(!this_value_possible){
                    possible = false;
                    break;
                }
            }

            int this_cost = cost(il, al, all_i1_a1);
            if(possible && this_cost < best_cost){
                best_cost = this_cost;
                best_il = il;
                best_al = al;
                best_all_i1_a1 = all_i1_a1;
            }
        }
    }

    // build and return bf code
    std::string bf_code = build_bf(best_il, best_al, best_all_i1_a1, positions, loop_position);
    lua_pushstring(L, bf_code.c_str());
    return 1;
}

// make the functions available to Lua
int luaopen_inc2_n(lua_State* L)
{
    luaL_Reg fns[] = { { "load", load }, { "inc2_n", inc2_n }, { NULL, NULL } };
    luaL_newlib(L, fns);
    return 1;
}
}
