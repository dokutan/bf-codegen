# fnl2bf.fnl

This is a Fennel library for working with Brainfuck code at a higher level.

**Note:** using the `inc2-3` function (and functions that depend on it) requires the following:
1. compile the `inc2_3_factors` module: `make` (or build it manually)
2. place the file `inc2-3.csv` (generated by `../constants/inc2-3.jl` or available from https://github.com/dokutan/bf-codegen/releases/tag/v0.1) in the same directory as the `inc2_3_factors` module

## Naming conventions:
symbol | meaning
---|---
`!` | modifies the current cell
`\` | requires manual initialization of cells that are not specified as a parameter

Parameters beginning with `temp` are always pointers to cells.

## `bf.shortest` (λ)
```(bf.shortest ...)```

Returns the shortest argument

## `bf.shortest-in` (λ)
```(bf.shortest-in tbl ?randomize)```

Returns the shortest element from `tbl`
If `?randomize` is true and there are multiple shortest elements, choose one randomly.

## `bf.loop` (λ)
```(bf.loop ...)```

A loop: [...]

## `bf.at` (λ)
```(bf.at distance ...)```

Move pointer by `distance`, insert body, move back

## `bf.ptr` (λ)
```(bf.ptr distance ?from)```

Move pointer by `distance`. If `?from` is not nil, assume the ptr starts at `?from`

## `bf.inc` (λ)
```(bf.inc value)```

Add `value` to current cell

## `bf.inc2` (λ)
```(bf.inc2 value temp ?temp-initial)```

Add `value` to the current cell, using `temp0`.
`temp0` must be 0 or have the value `?temp-initial`.

## `bf.inc2-2` (λ)
```(bf.inc2-2 value1 value2 at2 temp ?inc-after-loop)```

Increment the current cell by `value1` and the cell at `at2` by `value2`.
`temp` must be zero.
If ?inc-after-loop is `true`, add i1, i2 after the loop.

## `bf.inc2-3` (λ)
```(bf.inc2-3 value1 value2 value3 at2 at3 temp)```

*no docstring*

## `bf.inc2-n` (λ)
```(bf.inc2-n value at temp)```

Increment multiple cells using a single loop.
`value` is a list containing the values that should be added.
`at` is a list containing the positions of the modified cells.
`temp` is the position of a cell containing 0, used as a loop counter.

Example: `(bf.inc2-n [123 30 20 10] [0 1 2 3] 4)`

## `bf.zero` (λ)
```(bf.zero)```

Set current cell to 0

## `bf.set` (λ)
```(bf.set value ?initial)```

Set current cell to value

## `bf.set2` (λ)
```(bf.set2 value temp0 ?initial)```

Set current cell to value, using `temp0`. `temp0` must be 0.

## `bf.add!` (λ)
```(bf.add! to)```

Add current cell to `to`.
Sets the current cell to zero.

## `bf.multiply-add!` (λ)
```(bf.multiply-add! times to)```

Add the value of the current cell times `times` to `to`.
Sets the current cell to zero.

## `bf.sub!` (λ)
```(bf.sub! to)```

Destructively subtract current cell from `to`

## `bf.mul!` (λ)
```(bf.mul! y temp0 temp1)```

current cell <- current cell * cell at `y`.
`temp0` and `temp1` must to be 0.
`y` is not modified.

## `bf.square` (λ)
```(bf.square temp0 temp1)```

current cell < current cell ^ 2

## `bf.divmod\!` (λ)
```(bf.divmod\!)```

Current cell divided/modulo by the next cell to the right.
Uses 5 cells to the right of the current cell, cells must be initialized as shown:
- Before: `>n d 1 0 0 0`
- After:  `>0 d-n%d n%d n/d 0 0`

## `bf.divmod-by!` (λ)
```(bf.divmod-by! value)```

Current cell divided/modulo by value. Uses 5 cells to the right of the current cell.

## `bf.mod\!` (λ)
```(bf.mod\!)```

- before: `0 >n d 0 0 0`
- after: `0 >0 d-n%d n%d 0 0`

## `bf.invert` (λ)
```(bf.invert temp ?init)```

Equivalent to current cell <- (256 - current cell).

## `bf.mov!` (λ)
```(bf.mov! to)```

Destructively move current cell to `to`

## `bf.mov` (λ)
```(bf.mov to temp ?init)```

Copy value of the current cell to `to`, using `temp`.
`temp` and `to` must be manually set to 0, unless `?init` is true.

## `bf.add` (λ)
```(bf.add to temp)```

Add the value of the current cell to `to`, using `temp`.
`temp` must be zero.

## `bf.swap` (λ)
```(bf.swap y temp0)```

Swap the current cell with `y`, using `temp0`. `temp0` must be 0.

## `bf.not=!` (λ)
```(bf.not=! y)```

current cell <- current cell != cell at `y`. Sets `y` to 0.

## `bf.=!` (λ)
```(bf.=! y)```

current cell <- current cell == cell at `y`. Sets `y` to 0.

## `bf.<\!` (λ)
```(bf.<\! ?init)```

current cell <- current cell < next cell.
- before: >x y 0 0
- after: >(x<y) 0 0 0

## `bf.>!` (λ)
```(bf.>! x y z temp0 temp1 ?init)```

z = x>y
Modifies x and y. z, temp0 and temp1 must be zero, unless ?init is true.

## `bf.max` (λ)
```(bf.max x y maximum temp0 temp1 temp2 temp3 temp4)```



## `bf.min` (λ)
```(bf.min x y minimum temp0 temp1 temp2 temp3 temp4)```



## `bf.if` (λ)
```(bf.if ...)```

Equivalent to `[...[-]]`. Sets the current cell to 0.

## `bf.if=` (λ)
```(bf.if= value temp0 temp1 ...)```

If current cell == `value`, then ...
The body is run at `temp0` and should not change the ptr.

## `bf.if2=` (λ)
```(bf.if2= value temp0 temp1 temp2 ...)```

If current cell == `value`, then ...
The body is run at `temp0` and should not change the ptr.
`temp2`must be 0.

## `bf.if-not=` (λ)
```(bf.if-not= value temp0 ...)```

If current cell ≠ `value`, then ...
The body is run at the current cell.
Sets the current cell to 0.

## `bf.do-times` (λ)
```(bf.do-times n temp ...)```

Run the body `n` times.

## `bf.do-times-at` (λ)
```(bf.do-times-at temp ...)```

Run the body n times, n = value of `temp`.

## `bf.print!` (λ)
```(bf.print! str ?initial)```

Print `str` using the current cell.
The value of the current cell is assumed to be `?initial`, if given.

## `bf.print2!` (λ)
```(bf.print2! str temp0 ?initial)```

Print `str` using the current cell and `temp0`, `temp0` must be 0.
The value of the current cell is assumed to be `?initial`, if given.

## `bf.print2+!` (λ)
```(bf.print2+! str temp0 ?initial)```

Print `str` using the current cell and `temp0`, `temp0` must be 0.
The value of the current cell is assumed to be `?initial`, if given.

## `bf.print2++!` (λ)
```(bf.print2++! str temp0 ?initial)```

Print `str` using the current cell and `temp0`, `temp0` must be 0.
The value of the current cell is assumed to be `?initial`, if given.
TODO! Does not work reliably.

## `bf.print3!` (fn)
```(bf.print3! str temp0 temp1 ?initial)```

Print `str` using the current cell, `temp0` and `temp1`, `temp0` and `temp1` must be 0.
The value of the current cell is assumed to be `?initial`, if given.
`temp0` can have a non-zero value afterwards.

## `bf.print-from-memory` (λ)
```(bf.print-from-memory str memory ptr ?randomize ?zero-delimited)```

Print `str`, assumes the memory is initialized with the values from `memory`.
`memory` is modified in place.
`ptr` is the initial pointer position in `memory`.
`?randomize` is passed to `shortest-in`
Set `?zero-delimited` to true, if `memory` is delimited by 0 on both ends,
and doesn't contain 0. This makes pointer movement more efficient.

## `bf.string!` (λ)
```(bf.string! str move)```

Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.

## `bf.string-opt1!` (λ)
```(bf.string-opt1! str move)```

Slightly optimized version of `bf.string!`.
Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.

## `bf.string-opt2!` (λ)
```(bf.string-opt2! str move)```

Better optimized version of `bf.string!`.
Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.

## `bf.string-opt3!` (λ)
```(bf.string-opt3! str move)```

Optimized version of `bf.string!`.
Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.

## `bf.string-opt4!` (λ)
```(bf.string-opt4! str move)```

Optimized version of `bf.string!`.
Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.

## `bf.string-opt5!` (λ)
```(bf.string-opt5! str move ?loop-size)```

Optimized version of `bf.string!`.
Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.
?loop-size is the number cells changed with one loop, the default is 10.

## `bf.string2!` (λ)
```(bf.string2! str move temp0 initial)```

TODO! remove when bf.string2-opt! works
Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.
`initial` can be any number between 1 and 255.

## `bf.string2-opt!` (λ)
```(bf.string2-opt! str move initial)```

TODO! fails for some `initial` values
Store `str` in memory, starting at the current cell.
All used cells must be initialized as 0. `move` should be ±1.
`initial` can be any number between 1 and 255.

## `bf.optimize` (λ)
```(bf.optimize code ?steps)```

Remove useless combinations of brainfuck commands from `code`

## `bf.optimize2` (λ)
```(bf.optimize2 code ?steps)```

Remove useless combinations of brainfuck commands from `code`.
More aggressive version of `bf.optimize`.

## `bf.print-cell\` (λ)
```(bf.print-cell\)```

Print the value of the current cell as a decimal number.
Requires 6 cells containing 0 to the right of the current cell.

## `bf.print-cell-tens\` (λ)
```(bf.print-cell-tens\)```

Print the value of the current cell modulo 10 as a decimal number.
Requires 6 cells containing 0 to the right of the current cell.

## `bf.digits\` (λ)
```(bf.digits\)```

Creates a string containing the digits of the currrent cell as a decimal number.
- before: `[x], 0, 0, 0, …`
- after: `[x], 0, ones, tens, hundreds, [0]`

## `_generic-case` (λ)
```(_generic-case inc-fn temp0 temp0-init ?temp1 args body-zero)```

This function is used to implement both `bf.case!` and `bf.case2!`.
Do not use this directly.

## `_build-case-args` (λ)
```(_build-case-args inc-fn temp0 ?temp1 ...)```

This function generates the `args` for `_generic-case`.
Do not use this directly.

## `bf.case!` (λ)
```(bf.case! temp ...)```

A switch-case-like construct.
Takes an arbitrary number of value+code pairs and an optional default case.
The code will be run at `temp`.

## `bf.case2!` (λ)
```(bf.case2! temp0 temp1 ...)```

A switch-case-like construct.
Takes an arbitrary number of value+code pairs and an optional default case.
The code will be run at `temp0`.

## `bf.optimize-parms` (fn)
```(bf.optimize-parms func parms ?progress ?logfile)```

Optimize the independent parameters `parms` of the function `func`.
The goal is to find the parameters producing the shortest result of `func`.
The parameters should not influence each other and must be given as a table of
tables, each containing a minimum and maximum value, e.g. `[[1 100] [0 255]]`.
If `?progress` is true, print the progress to stderr.
If `?logfile` is a filename, a Julia script producing a plot of the result
length is generated.

## `bf.sample` (λ)
```(bf.sample func n ?logfile)```

Call `func` `n` times and return the shortest result.
Optionally write the lengths of all results to `?logfile`.

## `bf.popcount\!` (λ)
```(bf.popcount\!)```

Population count, count the number of 1s in the binary representation of the current cell.
- before: `[x] 0 0 0 0 0 0`
- after:  `[0] 0 0 0 result 0 0`

## `bf.double` (λ)
```(bf.double ...)```

Double the precision of the interpreter.
Each 16-bit cell is stored using 4 8-bit cells:
low reserved reserved high
^ptr


## `bf.D.ptr` (λ)
```(bf.D.ptr distance)```

Doubled version `bf.ptr`: move ptr 4 * `distance`.

## `bf.D.at` (λ)
```(bf.D.at distance ...)```

Move pointer by `distance`, insert body, move back

## `bf.D.zero` (λ)
```(bf.D.zero)```

Doubled version `bf.zero`.

## `bf.D.add!` (λ)
```(bf.D.add! to)```

Doubled version of `bf.add!`.

## `bf.D.sub!` (λ)
```(bf.D.sub! to)```

Doubled version of `bf.sub!`.

## `bf.D.multiply-add!` (λ)
```(bf.D.multiply-add! times to)```

Doubled version of `bf.multiply-add!`.

## `bf.D.mov!` (λ)
```(bf.D.mov! to)```

Doubled version `bf.mov!`. TODO optimize

## `bf.D.mov` (λ)
```(bf.D.mov to ?init)```

Doubled version `bf.mov`.
`to` must be manually set to 0, unless `?init` is true.

## `bf.D.set` (λ)
```(bf.D.set value)```

Set a doubled cell to `value`, the initial value must be 0.

## `bf.D.zero?!` (λ)
```(bf.D.zero?!)```

Check if a doubled cell is zero.

## `bf.D.divmod\!` (λ)
```(bf.D.divmod\! ?mod+1)```

Current cell divided/modulo by the next cell to the right.
Uses 5 cells to the right of the current cell, cells must be initialized as shown:
- Before: `>n d 1 0 0 0`
- After:  `>0 d-n%d n%d n/d 0 0`
If `?mod+1` is true, `n%d` is `n%d+1` instead.

## `bf.D.divmod2\!` (λ)
```(bf.D.divmod2\! ?mod+1)```

Current cell divided/modulo by the next cell to the right. Optimized for d<256.
Uses 5 cells to the right of the current cell, cells must be initialized as shown:
- Before: `>n d 1 0 0 0`
- After:  `>0 d-n%d n%d n/d 0 0`
If `?mod+1` is true, `n%d` is `n%d+1` instead.

## `bf.D.print-cell\` (λ)
```(bf.D.print-cell\)```

Print the value of the current doubled cell.
Based on: https://esolangs.org/wiki/Brainfuck_algorithms#Print_value_of_cell_x_as_number_for_ANY_sized_cell_(eg_8bit,_100000bit_etc)

## `bf.D.digits\` (λ)
```(bf.D.digits\)```

Doubled version of `bf.D.digits\`
- before: `{[x], 0, 0, x}, 0, 0, 0, …`
- after: `{x, 0, 0, x}, {0, 0, 0, 0}, ones, tens, hundreds, …, [0]`

## `bf.D.popcount\!` (λ)
```(bf.D.popcount\!)```

Population count of a doubled cell, count the number of 1s in the binary representation of the current cell.
- before: `[low] 0 0 high 0 0 0 0 0 0`
- after:  `[0] 0 0 0 result 0 0 0 0 0`

## `bf.triple` (λ)
```(bf.triple ...)```

Triple the precision of the interpreter.
Each 24-bit cell is stored using 7 8-bit cells:
a reserved reserved b reserved reserved c
^ptr

value = a + 256*b + 65536*c

## `bf.read-list` (λ)
```(bf.read-list move separator terminator ?no-initial-read)```

Read a list of integers, separated by `separator` and terminated by `terminator`.
The integers are placed `move` cells apart in memory.
Set `?no-initial-read` to true, if the current cell contains the first character of the sequence.

# Array1 functions
These functions operate on arrays that use a single cell per value.
Zero is not a valid value inside the array, because the array is delimited by zeros on both ends.

## `bf.array1.shiftr` (λ)
```(bf.array1.shiftr ?distance)```

Shift array right by `?distance` cells (default is one).
- before: `0, array, [0], 0`
- after:  `0, [0], array, 0`

## `bf.array1.shiftl` (λ)
```(bf.array1.shiftl ?distance)```

Shift array left by `?distance` cells (default is one).
- before: `0, [0], array, 0`
- after:  `0, array, [0], 0`

## `bf.array1.length` (λ)
```(bf.array1.length)```

Get the length of an array.
- before: `0, array, [0], 0, 0`
- after:  `0, array, [0], length, 0`

## `bf.array1.reverse` (λ)
```(bf.array1.reverse)```

Reverse an array.
- before: `0, array, [0], 0, 0`
- after:  `0, array, [0], 0, 0`

## `bf.array1.get` (λ)
```(bf.array1.get)```

Get an element of an array, the index is 0 based.
- before: `0, 0, array, [0], index, 0`
- after:  `0, 0, array, [0], result, 0`

## `bf.array1.set` (λ)
```(bf.array1.set)```

Set an element of an array to value, the index is 0 based.
- before: `0, 0, array, [0], index, value`
- after:  `0, 0, array, [0], 0, 0`

## `bf.array1.copyr` (λ)
```(bf.array1.copyr distance)```

Copy an array `distance` cells to the right.
- before: `0, 0, array, [0]`
- after: `0, 0, array, [0], ..., 0, array, 0`

## `bf.array1.copyl` (λ)
```(bf.array1.copyl distance)```

Copy an array `distance` cells to the left.
- before: `0, array, [0], 0`
- after: `0, array, 0, ..., 0, array, [0], 0`

## `bf.array1.strcomparel!` (λ)
```(bf.array1.strcomparel! str ?mode)```

Compare array with `str`, deletes the array and places the result to the left.
If `?mode` is 'not=' the result is the number of characters that are different,
else the result is 1 if the array and string are equal, if not then 0.
- before: `0, 0, array, [0]`
- after: `[result], 0, 0, 0, ...`

## `bf.array1.strcomparer!` (λ)
```(bf.array1.strcomparer! str ?mode)```

Compare array with `str`, deletes the array and places the result to the right.
If `?mode` is 'not=' the result is the number of characters that are different,
else the result is 1 if the array and string are equal, if not then 0.
- before: `[0], array, 0, 0`
- after: `..., 0, 0, 0, [result]`

## `bf.array1.sort` (λ)
```(bf.array1.sort)```

Sort array in place.
- before: 0, 0, array, [0], 0, 0, 0, 0, 0, 0

## `bf.array1.map` (λ)
```(bf.array1.map distance & code)```

Map `code` over array in place:
- before: `0, array, [0], 0
- after: `0, array, [0], 0
`code` is run in the following environment: `array, 0 * distance, [current element], array`

## `bf.array1.foldr` (λ)
```(bf.array1.foldr & code)```

Right fold, places the result in the leftmost element of the array.
- before: `0, array, [0]`
- after: `[0], result, 0, …, 0`
`code` is run in the following environment `array, [a], b, 0, …`, and must produce `array, [f(a,b)], 0, 0, …`

## `bf.array1.foldl` (λ)
```(bf.array1.foldl & code)```

Left fold, places the result in the rightmost element of the array.
- before: `[0], array, 0`
- after: `0, …, 0, result, [0]`
`code` is run in the following environment `…, 0, a, [b], array`, and must produce `…, 0, 0, [f(a,b)], array`

## `bf.array1.suml` (λ)
```(bf.array1.suml)```

Sum all elements in the array, the result is placed in the leftmost element.
- before: `0, array, [0]`
- after: `[0], sum, 0, …, 0`

## `bf.array1.sumr` (λ)
```(bf.array1.sumr)```

Sum all elements in the array, the result is placed in the leftmost element.
- before: `[0], array, 0`
- after: `0, …, 0, sum, [0]`

